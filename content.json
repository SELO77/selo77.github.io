{"meta":{"title":"SELO's Autobiography","subtitle":"SELO's LOG","description":"SELO's IT BLOG","author":"SELO77","url":"https://selo77.github.io"},"pages":[],"posts":[{"title":"Python- yield, generator, coroutine","slug":"Python-Asyncio","date":"2016-07-05T11:16:31.000Z","updated":"2016-07-06T00:20:37.000Z","comments":true,"path":"2016/07/05/Python-Asyncio/","link":"","permalink":"https://selo77.github.io/2016/07/05/Python-Asyncio/","excerpt":"","text":"AsyncIO ?아래 그림은 Python3.4 부터 적용된 asyncIO 라는 강력한 비동기 모듈의 프로세스를 간략하게 설명한 그림입니다. 보자마자 머리가 지끈 지끈 아파오기 시작하시져? 비동기, 병령처리, 동시성 너무나 자주 듣는 용어들이지만 깔끔하게 머릿속에 정리가 되지않습니다. 매일 같이 아래와 같은 코딩을 비동기 기반 개발을 함에도 불구하고 반에 반 밖에 이해를 못하고 코딩을 하는것 같습니다.ㅠㅠ 그래서 이번 기회에 포스팅을 통해 AsyncIO 비동기 모듈을 완벽 정복해보려 합니다. 1234567891011121314151617181920import asynciofrom module import module_dao, module_email@asyncio.coroutinedef an_asyn_fnc(): item = yield from another_asynfnc() asyncio.async(module_email(item.email)) return item@asyncio.coroutinedef another_asynfnc(): query = \"\"\" SELECT * FROM users WHERE userID = 'SELO' \"\"\" dt_user = yield from module_dao(query) if dt_user.get('succeed', None): return dt_user['item'] else: raise Exception (위 코딩은 너무 깊게 생각할 가치가 없습니다……. 하지만 한번 눈으로 보시면 아래 개념들을 이해하는데 조금은 도움이 될듯합니다.) yield, generator, coroutineAsyncIO 를 이해하기 위해서 사전에 알고가야 할 개념들이 존재합니다. 바로 오늘 같이 공부해볼 yield 키워드, generator 객체, coroutine 개념입니다. 먼저 yield 키워드와 generator 부터 살펴보겠습니다. return 처럼 yield는 값을 반환한다. 하지만 yield는 리턴 값을 비롯한 Context(환경) 포함한 제너레이터라는 객체를 반환하는데 이 제네레이터 객체는 iterable(순환가능) 합니다. 말이 상당히 야리꾸리 합니다. 처음에는 이해가 안되는게 당연합니다. 123456789101112for i in range(5): print(i, end= \",\") # 0,1,2,3,4,def custom_range(end): i = 0 while i &lt; end: yield i i += 1print()result = custom_range(5)print(result) # &lt;generator object custom_range at 0x1017c5a98&gt; 위 custom_range() 함수는 내장함수인 range() 함수를 제너레이터를 이용해 구현한 예입니다.위와 같이 구현된 함수를 코루틴 함수라 합니다. 코루틴? 제너레이터? 여기서는 하나만 기억하고 넘어갑시다. yield가 선언된 함수는 yield를 만나는 순간 제너레이터라는 객체를 반환한다!! 그러면 왜 제너레이터는 순환가능한 것인가? 왜 순환 가능하여야만 하는가? 아래 코드를 보면서 궁금증을 풀어봅시다. generator는 순환 가능!! 왜?123456789101112for i in result: print(i, end=',') # 0,1,2,3,4,print()print(list(custom_range(5))) # [0, 1, 2, 3, 4]print([i for i in custom_range(5)]) # [0, 1, 2, 3, 4]generator = custom_range(2)print(next(generator)) # 0print(next(generator)) # 1# 아래코드는 리스트의 아웃오브인덱스 예외와 유사하다. 더이상 진입점이 없으므로 예외를 발생시킨다.# print(next(generator)) # raise Exception StopIteration 위 generator 변수에 대입된 custom_range(2) 함수는 yield 키워드에서 값을 반환하고, 다음 next()에 의해 호출될 때까지 해당 라인을 진입점으로 기억해둡니다. 이러한 진입점이 여러 개 인 함수를 코루틴(coroutine) 이라하며, 기존에 우리가 주로 사용하는 코드를 순서대로 실행하다가 return 코드를 만나고 최종 값을 리턴하면서 context를 잃는 방식을 서브루틴(subroutine)이라고 합니다. 결론은 이미 첫째줄에 말씀드렸는데요. “yield를 만나는 순간 Context(환경)를 포함한 제너레이터라는 객체를 반환.” 결국 제너레이터라는 객체는 코루틴이라는 함수가 진입점을 여러 곳 갖고 있기때문에 호출되는 순서에 따라 Context(환경)이 달라지게 됩니다. 이로 인하여 iterable(순환가능) 할 수 밖에 없는 숙명을 띠게 됩니다. ReferencePython 3, asyncio와 놀아보기rochan87@gmail.com 필자의 머릿속. 잘못된 정보에 대한 지적은 언제든지 감사히 받겠습니다.","categories":[{"name":"Python","slug":"Python","permalink":"https://selo77.github.io/categories/Python/"},{"name":"Language","slug":"Python/Language","permalink":"https://selo77.github.io/categories/Python/Language/"}],"tags":[{"name":"python","slug":"python","permalink":"https://selo77.github.io/tags/python/"},{"name":"yield","slug":"yield","permalink":"https://selo77.github.io/tags/yield/"},{"name":"generator","slug":"generator","permalink":"https://selo77.github.io/tags/generator/"},{"name":"coroutine","slug":"coroutine","permalink":"https://selo77.github.io/tags/coroutine/"},{"name":"asyncio","slug":"asyncio","permalink":"https://selo77.github.io/tags/asyncio/"}]},{"title":"나는프로그래머다 - 나프다컨 복기","slug":"iamprogrammer-conference-review","date":"2016-06-25T08:26:51.000Z","updated":"2016-06-25T10:59:26.000Z","comments":true,"path":"2016/06/25/iamprogrammer-conference-review/","link":"","permalink":"https://selo77.github.io/2016/06/25/iamprogrammer-conference-review/","excerpt":"","text":"나는프로그래머다 참여 후기 1부제목은 참여 후기지만 실상은 두서없는 주저리가 될 것이다. 복기나는 프로그래머다 일명 나프다 개발자 컨퍼런스에 참여했다. 컨퍼런스에서 느낀점을 두서 없이 복기 해볼까한다. 자꾸 복기라는 단어를 선택해서 사용하는 것을 이 글을 읽는 분이라면 느꼈을 것이다. 그 이유는 컨퍼런스에서 데니스님이 언급하신 내용 때문이다. 복기란 바둑에서 주로 쓰이는 단어로서 대국이 끝난 후 상대방과 두었던 수에 대해 복습을 의미한다. 나는 학습하는 과정에서 복기를 중요시 여기지 않으며 살아왔다. 내 자신에 대한 자만인지 뭔지는 모르겠지만 한마디로 허접하게 살아왔다. 바둑을 잘 모르는 나를 포함한 많은 사람도 이세돌의 이름 한번쯤은 들어 봤을 것이다. 이세돌은 어떻게 세계최고의 바둑기사가 되었을까? 타고난 천재적 재능? 금수저? 좋은환경? 물론 위에 이유들도 무시할 수는 없을 것이다. 하지만 그는 대국 후 철저한 복기를 하기로 유명하다. 알파고와 대국이 끝난 뒤에도 동료 기사들과 밤새 복기를 했다고 한다. 결론 적으로 알파고가 이겼지만 3연패 뒤 이세돌은 3연승 보다 값진 1승을 이루어 내었다. 그의 1승은 결코 우연이 아닐 것이다. 나는 그의 1승의 가장 큰 이유는 연속된 패배에도 멈추지 않았던 복기를 뽑고 싶다. 복기를 통해 알파고의 약점을 집요하게 파악했고, 자신의 부족함을 보강해 나갔을 것이다. 뛰어난 사람은 생각보다 많다. 특히 나프다 컨퍼런스와 같음 모임에 참여하면 한없이 부족함을 깨닫게 된다. 사실 나같은 경우는 자만할 실력도 없긴하다. 현재는 그렇다. 말하고 싶은 요점은 하나다. 뛰어난 사람은 많지만 인정받는 사람은 많지 않다는 점이다. 인정받는 사람 사람이 되기 위해서는 자기 세상에 빠져서는 안된다. 주변을 볼줄 알아야 하고 그렇기 위해서는 항상 깨어있어야한다. 이런 점에 복기는 최고의 방법이 될 수 있다. 나는 뛰어난 사람이 되고 싶다. 하지만 인정받지 못하면서 뛰어난 사람이 되고 싶지는 않다. 내가 삶을 살아가는 이유는 내가 사랑하는 사람들에게 인정받고, 내 자신 스스로에게도 인정받고 싶기때문이다. 임백준 작가님께서 라이브 코딩을 선사한 대마고학생들의 뛰어난 재능에도 불구하고 걱정을 표현했던 부분이 이와 같은 맥락이 아닐까 생각한다. 자유와 행복이번 주저리는 3번째 세션을 중심으로 이야기를 진행해보겠다. 3번째 세션의 트랙1은 염산악님과 정개발님의 ‘코딩인터뷰 준비 티끌 가이드’였고, 트랙2는 박현천님의 ‘자유와 일을 사랑하는 개발자, 디지털 노마드를 말하다.’ 였다. 나는 트랙2의 박현천님의 트랙을 들었다. 그 이유는 단순하다. 자유라는 주제를 다루고 있었기 때문이다. 왜 개발자로서 삶을 선택했가? 먹고 살기 위해서? 개발이 좋아서? 그냥? 여기에 정답은 없지만 모법답안은 개발이 좋아서 일것이다. 개발이 좋아서 라면 왜 개발이 좋은가? 이 부분을 답하는데 고민이 생긴다면 한번쯤 생각해 보자. 내가 개발을 하는 가장 큰 이유는 자유다. 개발자란 직업은 다른 직업에 비해 자유롭다. 물론 이에 대해 반대되는 의견도 많을리라 생각한다. 하지만 개발자란 단어 그대로 의미를 생각해보면 무언가를 개발하는 직업은 다른 직업에 비해 자유도가 매우 중요하다 생각한다. 나의 부족한 식견때문인지 머릿속에서 맴도는 생각이 잘 정리가 되지 않지만ㅠㅠ 개발자에게 자유는 매우 중요하다. 구체적인 설명이 힘듬으로 예를 들어 설명해보겠다. 최고의 회사 구글을 살펴보자. 그들의 회사는 정해진 규율안에 매우 자유롭다. 강아지와 함께 출근을 하거나 필요한 경우에 원격근무를 하고, 자유로운 복장으로 출근한다. 이외에도 수도 없이 많다. 그리고 그들은 지구 최고의 회사다. 지금으로서는 그렇다. 나의 꿈은 적당히 돈 있는 한량이다. 한량 == 백수. 이유는 간단하다 나는 내가 하고싶은 일을 할 수 있는 자유가 있을때 행복하다. 한량은 자유롭다. 이렇게 내가 쓰고 싶은 말을 하고, 생각하고, 하고 싶은일을 하고, 사랑하는 사람과 함께하며, 사람들에게 인사이트를 주고싶다. 죽을때까지 이꿈을 이룰수 있으리라는 보장은 없지만 이런 미래에 대한 목표가 나를 이끄는 원동력이다. 주저리를 정리해보자면 박현천님의 트랙에 생각보다 적은 사람이 와서 아쉬웠다. 코딩인터뷰 물론 개발자에게 매우 중요한 주제다. 구글의 염산악님과 정개발님께서 발표를 해주신다니 나 같아도 자유라는 단어가 포함된 트랙이 아니였다면 그 트랙에 참여했을 것이다. 코딩인터뷰를 준비하고 좋은 회사에 들어가기 전에 본인이 왜 개발을 이렇게 열정적으로 하고 있으며, 개발을 할때 진정 행복한지 한번 쯤 고민을 해보는 시간이 필요하다 생각한다. 특히 “나는 왜 개발하는가?” 질문에 답변이 힘들었다면 말이다. 데니스데니스님은 귀엽다. 진심이다. 참고로 필자는 약혼자가 있다. 오해금물. 나는 데니스 같은 분을 좋아한다. 나는 데니스님을 보면 김구라가 떠오른다. 나는 김구라도 좋아한다. 데니스는 김구라와 비슷하다. 이 문장은 논리적인가? 삼단추론논법인가 대기업 취업준비를 할때 이런 문장이 논리적인지 판단하는 문제를 풀곤했다. 아무튼 데니스를 김구라에 비유하는 이유는 두분다 독설가이다. 본인이 아니다 하는 생각에 대해서는 열정적으로 비판한다. 비판가는 욕먹기 십상이다. 특히 흑백논리가 편협한 대한민국에서는 그렇다. 임작가님과 같이 노련한 비판가들은 은유적으로 비판한다. 야생에서 오래 서식한 데니스님은 야생마다(발음조심) 우선 아니다 싶으면 아니다 말한다. 컨퍼런스 중에서도 이런면이 여김없이 들어났다. 가끔 마이크를 돌진하시더라.. 가끔은 안쓰럽기도 하다. 나프다 방속에서 어떤 이야기를 함에 있어 임작가님과 데니스님의 맥락이 같음에도 불구하고 데니스님만 욕을 먹을때가 있는 것같다.ㅠㅠ 이래서 표현방식이 중요하다는 것인가?! 하지만 야생마에게 이런 것을 요구하는 오른방법이 아니다. 야생마는 야생마이기에 멋이 있는 것이다. 내가 생각하는 대한민국에는 더 많은 야생마가 존재해야한다. 더욱 비판하고, 잘못됨을 일깨워 줘야한다. 데니스님이 꼭 오른말은 한다는 것이 아니다. 다양한 생각이 교류 될 수 있는 환경이 만들어져야 한다는 것이다. 그렇기 위해서는 야생마를 길들여 경주마로 만들려고 하기보다는 야생마가 더 뛰어 다닐 수 있는 환경이 만들어 져야하지 않을까 생각해본다. 결론 데니스 = 야생마(발음조심) 항상 머릿속에만 있던 생각을 글로 이렇게 표현 하려니 기운이 쏙쏚 빠진다ㅠㅠ 그래서 너무 배가 고프다. 친구가 왔다. 밥먹으러 가야한다. 그러므로 후기 2부는 다음에 작성해야지~~ 읽어 주시는 분이 있을지 모르지만 읽어 주셨다면 감사합니다(꾸벅). 아 그리고 어떤 의견이든 환영합니다. 마지막으로 우리는!!! 프로그래머닷!!! 아참 한빛소프트 부스에서 나프다 2권도 구입!!!사실 대살개문이 더 끌렸지만 좋은 방송을 듣게 해주는 고마움의 표현. 나프다 구입 결정!!! Related Posts","categories":[{"name":"Memorandum","slug":"Memorandum","permalink":"https://selo77.github.io/categories/Memorandum/"}],"tags":[{"name":"나는프로그래머다","slug":"나는프로그래머다","permalink":"https://selo77.github.io/tags/나는프로그래머다/"},{"name":"나프다","slug":"나프다","permalink":"https://selo77.github.io/tags/나프다/"},{"name":"개발자모임","slug":"개발자모임","permalink":"https://selo77.github.io/tags/개발자모임/"},{"name":"iamprogrammer","slug":"iamprogrammer","permalink":"https://selo77.github.io/tags/iamprogrammer/"}]},{"title":"Git 개념 및 유용한 사이트","slug":"git-definition-usefulsite","date":"2016-06-24T12:10:09.000Z","updated":"2016-06-25T10:51:23.000Z","comments":true,"path":"2016/06/24/git-definition-usefulsite/","link":"","permalink":"https://selo77.github.io/2016/06/24/git-definition-usefulsite/","excerpt":"","text":"서론안녕하세요. 새로입니다. 오늘은 오픈소스 저장소로 유명한 Git에 대해서 알아보는 시간이 되겠습니다. 이번 토픽을 Git으로 선정하게 된 이유는, 몇일전 회사에서 신규서비스 오픈 중 개고생을 했기때문인데요. 머지와 리베이스 그 지옥에서 벗어나기 위해 발버둥 첬던 밤샘작업. 그 뼈아픈 경험때문에 이번 기회에 git의 필요한 부분을 정리하기로 마음먹었습니다. 포스팅 주제와 관련된 필자의 수준은 다음과 같습니다.(2016-06-06) 능력 평가는 지극히 주관적임을 먼저 밝힙니다. SVN(형상관리툴) 사용경험 없음. 참여한 모든 프로젝트에서 Git을 사용했었음 동료에게 피해주지 않을 만큼 정도의 Git사용 실력(가장 중요한 부분!!!) Ps. 누군가 싼 똥은 다른 사람에게 전파된다….. Git 개념먼저 시작하기전에 Git의 기본 개념에 대해 알고 넘어가야겠G요. Git이란 버전관리 시스템으로 쉽게 이해하면 소스코드의 백업공간입니다. 보고서나 어떤 문서를 작성할때 원본파일을 복사하여 복사본을 만들고 수정하셨던 경험이 있을 것입니다. 하지만 파일을 편집할 때 마다 복사본을 만드는 것은 우리모두의 치명적 약점. 언제나 실수 할 수 있다는 점을 생각했을 때 좋지 못한 방법입니다. 그리고 더욱 치명적인 것은 그 작업을 여러명이 진행할 때 실수 확률은 훨씬 더 클것입니다. 언제나 그랬듯이 우리는 우리의 약점을 보완하기 위한 도구를 만들게 됩니다. 그것이 바로 Git과 같은 버전관리 시스템입니다. Git에 대한 수다Git의 사용법은 이 포스팅에서는 따로 하지 않겠습니다. 이유는 체계적으로 정리된 튜토리얼 사이트가 많이 존재하기 때문입니다. 그래서 저는 Git을 사용하면서 느꼈던 점과 중요 포인트를 정리할 예정이며, Git을 공부하실때 제가 언급한 포인트를 생각하면서 공부하시면 좋을것 같습니다.(이번 Git 포스팅은 회사 서비스 오픈과 겹쳐 성의가 많이 떨어짐을 양해 부탁합니다(꾸벅)……….. 우쒸 보기 싫음 보지마 퉤……) 팀원 모두가 잘쓰면 정말 좋은 Git, 아니라면 I’m sure that your team will be in HELL soon. Git을 처음 사용하면 생각보다 복잡한 개념과 사용법에 고전하게 됩니다. 그렇다고 하던 개발을 멈추고, Git을 공부하기란 쉽지않습니다. 결국 개발은 개발대로 진행하고, remote repository에 Push나 Merge를 할때 동료직원중 Git 고수를 소환하여 문제를 해결합니다. 여기까지는 별 문제가 없습니다. 하지만 언제나 함께였던 Git고수 동료가 없을때 문제가 발생합니다. 평소 하던대로 커밋을 하고 풀을 받고, 푸쉬를 하려합니다. 하지만 오랜만에 머지를 해서 그런지 충돌이 난 것같습니다. 충돌때문에 푸쉬가 되지않습니다. 여기서 부터 당황하기 시작합니다. 침착하게 소스코드를 확인합니다. 하지만 방금전까지 멀쩡하던 코드에 뒤죽박죽 빨간줄이 생기고, 에러 천국이 되어버렸습니다. Git을 욕하기 시작합니다. “이 썅개뭐같은것 이딴거 왜쓰는거야?!!”. 욕하는 것도 잠시. 개발한 소스를 갱신하지 않으면 다른 동료 작업에 지장이 있기에 최대한 빨리 푸쉬를 해줘야합니다. 에라 모르겠다. 기존에 백업해둔 로컬 파일을 덮어쓰고 푸쉬합니다. 분명 자기자신만 사용하던 하위 브랜치기에 문제가 없으리라 생각합니다. 참고로 로컬에서는 정상적으로 잘 동작하던 소스였습니다. 다음날 오전…. 해맑게 웃으며 동료들과 스크럼 미팅을 진행합니다. 어제 개발 반영한 것에 대해 다음 작업을 진행할 동료에게 내용을 전달합니다. 5분뒤 누군가의 비명소리가 들려옵니다. “만어ㅣㅁ나어미나엄니ㅏ엄니ㅏ어마ㅣㄴ어ㅣ 내 소스 어디갔어 꺄오꺄오 ㅅㅍㅅㅍ!!!!!” 본능적으로 느낍니다. ‘나구나’ Git을 사용하면서 Overwrite을 하는것은 절대적으로 피해야합니다. 충돌은 반드시 소스 내에서 해결하여야 합니다. Git 가지를 치자!!!Git을 사용하다보면 어마무지한 뻘짓들을 하게 됩니다. 그러면서 얻은 교훈은 가지를 치자 가지치는데 돈 안들고 가지를 잘 칠 수록 행복해지리라~~!! 제가 사용하는 깃방식을 예를 들면 뿌리 (master)를 토대로 기둥(develop)으로 파생되고, 중심가지(서비스 카테고리. 지금 하는 서비스 같은 경우는 항공, 호텔, 보험 등)들이 자라납니다. 여기까지는 아주 훌륭합니다. 그러나 각 파트에서 개발하는 기능들은 가지를 치지 않는 경우가 발생합니다. 여기서 문제가 발생합니다. 가지를 치지 않은상태에서 진행중인 개발사항을 커밋을 하고 푸쉬를 했다고 칩시다. 그런데 다른 팀원의 기능개발이 끝나 develop 브랜치와 머지를 진행한다 합니다. ‘헐…. 나는 아직 안되는데……. 어쩌지어쩌지 !!! 으악.’ 브랜치만 잘 땃어도ㅠㅠ. 물론 해결방법은 있습니다. 하지만 쓸데없이 추가되는 비용을 발생시킬 필요는 없겠죠~ Git은 가지치기 위해 존재한다. 고로 가지를 치라!! Git 고수가 되고 싶나?아래 reference만 진행하셔도 이미 당신은 깃 고수. 지금 바로시작하세요. 사실 이번 포스팅 Git은 작성하는 동안 흥미가 떨어져서 ㅠㅠ 주저리가 많았네요. 양해부탁드립니다…..(쪼쪼) Reference Git 브랜치 배우기Git으로 협업을 진행할때 가장 중요한 개념인 branch에 대하여 튜토리얼을 통해 학습 할 수 있는 사이트입니다. 제가 PM이라면 신입사원에게 이 사이트의 튜토리얼을 모두 완수하라는 특명을 내리겠습니다!! git - 간편안내서Git의 주요 명령어들이 어떤 상황에서 사용되어야 하는지 쉽게 이해할 수 있는 사이트입니다. 기본적인 git 사용법을 알고 있을때 전체적으로 훓어보기 좋습니다. 누구나 쉽게 이해할 수 있는 Git 입문이 사이트의 내용을 모두 이해하셨다면 나는 이미 Git 도사!!! Git의 전반적인 내용을 다루고 있습니다. 버전관리 시스템을 처음 접하시는 분 부터 이미 Git을 사용하시는 분까지 적합한 사이트입니다. 아래 코드는 에러코드입니다. 신경쓰이겠지만 신경쓰지마세요.123456789101112131415161718192021222324252627class Git(version_control_system): local = &#123; \"master\" : source \"develop\" : source0 \"feature\" : &#123; \"new_service\" : source1_0, \"new_feature\" : source2, &#125; &#125; remotes.origin = &#123; \"master\" : source \"develop\" : source0 \"feature\" : &#123; \"new_service\" : source1 &#125; &#125; def __init__(self): def commit(self): def push(self): def pull(self): def checkout(self): def merge(self): def rebase(self): Related Posts","categories":[{"name":"DevEnv","slug":"DevEnv","permalink":"https://selo77.github.io/categories/DevEnv/"},{"name":"Git","slug":"DevEnv/Git","permalink":"https://selo77.github.io/categories/DevEnv/Git/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://selo77.github.io/tags/GitHub/"},{"name":"Git","slug":"Git","permalink":"https://selo77.github.io/tags/Git/"},{"name":"DevOps","slug":"DevOps","permalink":"https://selo77.github.io/tags/DevOps/"}]},{"title":"NoSQL 개념 및 종류","slug":"nosql-definition-basic","date":"2016-06-24T03:01:13.000Z","updated":"2016-06-24T11:50:52.000Z","comments":true,"path":"2016/06/24/nosql-definition-basic/","link":"","permalink":"https://selo77.github.io/2016/06/24/nosql-definition-basic/","excerpt":"","text":"NoSQL 그리고 MongoDB 입문 NoSQL 개념과 특징 NoSQL 탄생배경 NoSQL 분류 언제 어떤 NoSQL을 사용해야 하는가? 결론 Reference Related Posts NoSQL 그리고 MongoDB 입문이번 Side Project의 기술 스택으로 Meteor를 채택 진행하게되었고, 나는 Data Modeling을 맡았다. 그러나 RDBMS만 사용해본 나에게 모든 것은 새롭게 다가 왔고, Mean Stack이나 Meteor Tutorial 정도만 진행한 미천한 실력으로는 어려움을 느꼈다. 그렇게 프로젝트의 성공을 위해 NoSQL 공부를 시작한다. 이 글의 작정자의 수준은 아래와 같습니다. RDBMS 중급. MySQL, ORACLE 사용 경험 RDBMS data Modeling 초급 Redis 초급 NoSQL 초급 NoSQL 개념과 특징NoSQL : Non-Relational Operational Database SQL. 또는 Not only SQL마틴 파울러의 [NoSQL: 빅데이터 세상으로 떠나는 간결한 안내서]에서 NoSQL은 아래의 조건을 만족하는 데이터라 정의했다. 대용량 웹 서비스를 위하여 만들어진 데이터 저장소 관계형 데이터 모델을 지양하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화된 저장소 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소 NoSQL을 잘못 이해하면 스키마가 없는 DataModel 이라 이해할 수 있는데 그렇지 않다는 점을 집고 넘어가자. NoSQL은 각 시스템 마다 고유한 특징을 가진다. 하지만 일반적인 특징을 정의하고 넘어가자면, 읽기 작업보다 쓰기 작업이 더 빠르며, 일반적으로 RDBMS에 비하여 쓰기와 읽기 성능이 월등히 빠르다. 그러나 NoSQL은 제대로 알고 쓰지 못하면 성능 저하를 불러오고, 문제를 발생시킨다. 필자가 참여한 프로젝트에서는 검색속도 개선을 위해 Redis를 사용하는데 서버가 죽는 경우 Redis를 갱신시키는데 많은 시간을 소모하여, 복구 작업이 몇배는 더 걸린 경험이 있다. NoSQL 탄생배경NoSQL이 뭐시고 저시고 공부를 하다 문득 한가지 의문이 생겼다. RDBMS라는 확고한 Database 시스템이 존재하는데!!!! 왜???? 기존의 패러다임과는 너무나도 상반된 NoSQL 시스템이 나타난것인가?!!! 빅데이터 세상을 맞이함에 있어 구글과 같은 대규모 서비스 업체들은 관계형 데이터베이스 만으로 트래픽을 감당하기 어려워젔고, 이를 해결 하기 위한 결과로 NoSQL을 탄생시켰다. NoSQL은 분산 환경에서 대용량의 데이터를 빠르게 처리하기 위해서 단점을 가진채 개발되었다. NoSQL 분류NoSQL은 분류 방식에 따라 다르게 나누어진다. 이 글에서는 키에 저장된 값의 데이터 형식에 따라서 분류하겠다. 키-값 모델 키 값 모델의 가장 큰 특징은 단순한 저장구조를 갖으며, 복잡한 조회 연산을 지원하지 않는다. 저장되는 값을 단지 의미 없는 바이너리 데이터로 처리. 고속 읽기와 쓰기에 최적화된 경우가 많다. 키-값 모델 NoSQL 예 : Redis, Riak 등 키-값 모델의 특징을 고려해 볼때, 단일 연산에 처리할 수 있는 데이터들을 저장하는데 적합하다. 참여한 프로젝트의 경우는 자주검색되는 데이터를 Redis에 set하고, RDBMS 조회전에 Redis를 먼저 바라봄으로서 검색속도를 비약적으로 개선했다. 결론, 하나의 서비스 요청에 단일 연산 처리로 대응할수 있는 시스템에 적합하다. 문서 모델 문서모델 NoSQL 은 하나의 키에 구조화된 문서를 저장하고 조회한다. 문서모델에서 의미하는 구조화된 문서란 가장 대표적으로 JSON이 있으며, XML과 같이 구조를 갖는 문서를 말한다. 저장된 문서를 컬렉션으로 관리하고, 저장과 동시에 문서 ID에 대한 인덱스를 생성한다. 문서모델의 키는 문서에 대한 ID로 표현됨. 키-값 및 컬럼 모델에 비하여 많은 종류의 기능을 제공하며, RBMS와 유사한 검색조건을 포함한 쿼리를 처리할 수 있다. 이러한 특징 덕분에 문서모델 NoSQL은 많은 인기를 얻고 있다. 대부분의 문서 모델 NoSQL은 B트리 인덱스를 사용하여 2차 인덱스를 생성한다. 그러나 B트리는 크기가 커질수록 새로운 데이터를 입력하거나 삭제할때 성능이 떨어지게 된다. 이러한 이유로 B트리를 사용하는 문서 모델 NoSQL은 읽기와 쓰기 비율을 7:3 이상으로 유지할때 더 좋은 성능을 보인다. 결국 사용하는 문서 모델 NoSQL의 특징을 파악하고 사용하자. B트리의 특성 떄문에 한 번 작성되면 자주 변하지 않는 정보를 저장하고 조회하는데 적합하며, 로그저장, 타임라인 저장, 채팅로그 기록이나 조회에 적합하다. 문서 모델 NoSQL 예: 많은 인기를 얻고 있는 MongoDB NoSQL의 개념을 빠르게 잡고 MongoDB를 학습, 프로젝트를 진행할 예정이다. 여러분 함께해요~. 그 밖의 모델 위 두가지 모델 이외에도 컬럼 모델 NoSQL, 그래프 모델 NoSQL 등이 있으나 필자의 능력을 벗어남을 판단했다. 다음 가장 중요한 파트라 생각되는 “언제 어떤 NoSQL을 사용해야 하는가?”로 넘어가겠다. 언제 어떤 NoSQL을 사용해야 하는가?NoSQL은 RDMS를 단순히 대체하기 위해 나온 시스템이아니다. 그렇기에 정확한 기본지식 없이 사용하면 많은 시행착오와 장애를 맞이하게 될 수 있다그렇다면 NoSQL 시스템을 서비스에 적용하기 위해서는 무엇이 필요할지 정리해 볼 것이다.작성자의 수준에 맞춰 이해가 어려운 부분은 제외 하였으니 더 많은 정보를 원한다면 아래 Reference를 참고하기 바란다. 대량의 단순 정보를 빠르게 저장하고 조회할 때, 관계형 데이터베이스가 처리하지 못하는 대량의 데이터를 입력할때 스키마가 고정되지 않은 데이터를 저장하고 조회할 떄 등이 이에 해당된다. 하지만 위와 같은 상황에서 무턱대고 아무 NoSQL을 적용한다면 큰 낭패를 보게 될 것이다. 결국 시스템의 상황을 고려하여, 서비스 특징에 맞는 적합한 NoSQL 저장소를 택하여야 한다. NoSQL의 선택에 있어 고려해야 할 사항으로는 다음과 같다. 일관성 모델 : 서비스에서 저장하려는 데이터가 어느 정도의 일관성이 필요한지 확인하여야한다. 데이터 모델 : 저장하려는 데이터가 키-값 모델과 같은 간단한 데이터 모델로 처리가 가능한지 또는 문서 모델과 같이 중첩된 구조를 지원해야 하는지 판단해야 한다. 읽기 쓰기 성능 : 앞에서 말했듯이 읽기와 쓰기 비율에 따라서 적합한 NoSQL이 다르다. 빠른 응답시간이 필요하다면 인메모리 NoSQL이 적합하며, 상대적으로 읽기 비율이 높다면 문서-모델 NoSQL이 후보가 될 수 있다. (듣던 중 반가운 소리!! 필자가 개발하는 서비스의 특성상 읽기의 비율이 높다.) 원자성 지원 : 선택한 NoSQL의 트랜잭션 지원 여부, 단일 연산에 대한 연자성 지원 여부 등도 학인해야 한다. (이 부분은 확인 필요) 결론장점만 갖는 시스템은 존재하지 않는다. NoSQL의 환상에 빠지지 말고, 서비스가 NoSQL 적용이 적합한지, 적합하다면 어떤 NoSQL 이 알맞는지 판단하여야 할 것이다. 위 내용은 아래 Reference의 내용을 토대로 작성되었습니다. 특히, 이번 포스팅은 제가 즐겨 듣는 팟케스트 꿈과 희망의 나는프로그래머다 공식 후훤사 한빛미디어의 책 “정경석 - 이것이 Redis다” 를 주로 참고하였습니다. Referencehttp://bcho.tistory.com/666http://bcho.tistory.com/665https://velopert.com/436책 : 정경석 - 이것이 Redis 다 Related Posts","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"https://selo77.github.io/categories/NoSQL/"},{"name":"Basic","slug":"NoSQL/Basic","permalink":"https://selo77.github.io/categories/NoSQL/Basic/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"https://selo77.github.io/tags/NoSQL/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://selo77.github.io/tags/MongoDB/"},{"name":"Redis","slug":"Redis","permalink":"https://selo77.github.io/tags/Redis/"},{"name":"Database","slug":"Database","permalink":"https://selo77.github.io/tags/Database/"}]},{"title":"Python - Python?","slug":"Python-definition","date":"2016-06-23T11:17:28.000Z","updated":"2016-07-05T12:01:05.000Z","comments":true,"path":"2016/06/23/Python-definition/","link":"","permalink":"https://selo77.github.io/2016/06/23/Python-definition/","excerpt":"","text":"Python 이란? 사랑입니다. 개요 특징 높은 생산성 간결 그리고 아름다움 반복 가능한 객체 만능 언어 결론 Reference Related Posts Python 이란? 사랑입니다.이 포스팅은 가로 1400px 이상의 화면에 최적화 되있습니다. 저는 Python 개발자입니다. 매일 같이 Python을 사용하여 로직을 구현하고, 프로그램을 작성합니다. Python은 정말 재밌습니다. 간결한 문법, 상상을 뛰어넘는 가독성!! 무엇보다 생산성에서는 제가 접한 몇개 안되는 언어들 중 최고에 속합니다. 또한 풍부한 모듈과 내장함수들은 Python과 사랑에 빠지게 만듭니다. 그러나 Python에 대한 열정만큼 Python을 특징을 잘 파악하지 못하고, 단순히 내장함수나 모듈을 쓰는 단계에서 그치는 것이 아닌가 라는 걱정을 하게되었고, 파이썬의 특징을 집고 넘어가자는 취지로 포스팅하게 되었습니다. 포스팅 주제와 관련된 필자의 수준은 다음과 같습니다. (능력 평가는 지극히 주관적임을 밝힙니다.) 사용가능 언어 - Java7 중급 - Python3 중급 - ECMA6 중급 (하나 라도 제대로 해야할텐데 ㅠㅠ 그래서 요즘은 파이썬에 집중하려 합니다. 하지만 이놈의 호기심 때문에 함수형 언어에 기웃기웃하고 있네요.) 개요파이썬은 1989년 귀도 반 로썸의 재미로 만들어젔습니다. 리눅스 토발즈의 리눅스도 그렇고 천재들은 심심할때 대작을 만드는 듯합니다. 파이썬은 문법이 매우 쉬워서 초보자들이 처음 프로그래밍을 배울때 추천되는 언어이며, 동시에 실사용률과 생산성도 높은 강력한 언어입니다. 2016년 5월 기준 토비 프로그래밍 언어 월간 점유율 을 확인해보시면 현재 5위에 랭크되있습니다. 범용 프로그래밍언어로서 초보자부터 전문가까지 넓은 사용자층을 보유하고 있습니다. 변수의 자료형을 선언하지 않는 동적 타이핑 언어 이며(Runtime에 자료형을 검사), 인터프리터 에 의해 해석과 동시에 프로그램이 실행되는 스크립트 언어입니다. 파이썬은 현재 지속적인 발전과 더 많은 사용자층을 확보해가고 있습니다. 구글에서는 C++, JAVA와 함께 3대 개발 언어 중 하나로 알려져 있습니다. 최근 파이썬은 deep learning, data science 등 트렌디한 분야에서 특히 많이 사용되고있습니다. machine learning에 관심 있는 분이라면 Google이 개발한 deep learning 라이브러리인 TensorFlow를 권해드립니다. 역시 구글신!! 특징파이썬은 정말 다양한 분야에서 쓰이고있습니다. 그 이유는 파이썬의 다양한 특징때문일 것입니다. 그럼 같이 파이썬에 특징에 대해 알아볼까요. Here we go~!! 높은 생산성Life is short, you need python (인생은 너무 짧으니 파이썬이 필요해)인터프린트 언어이면서 우수한 자료형과 내부 모듈 등을 제공해 개발기간을 단축시킬 수 있습니다. 또한 수많은 오픈 서드파트 라이브러리를 사용하시면 그 속도를 배가 시킬수있습니다.빠른 아이디어 구현이 중요한 연구소에서 각광 받고 있으며, 우리나라에서는 정부의 자바라는 큰 장벽이 존재함에도 불구하고, 스타트업에서 가장 많이 사용하는 언어 중 하나입니다. 기술트렌드에 민감한 스타트업 기업들을 위한 전문 채용 사이트 살펴본다면, Python의 인기를 실감할 수 있습니다.로켓펀치 - 스타트업 백과사전PS. 사실 파이썬은 우리나라를 제외한 다른 나라에서는 이미 오래전부터 주류 언어로 사용되고 있었습니다. 간결 그리고 아름다움아름다움의 정의는 개개인마다 다를 수 있습니다. 하지만 다수가 인정하는 미의 기준은 한 곳에 수렴하기 마련입니다. 파이썬의 디자인 철학은 아름다움의 수렴이라는 포커스에 맞춰져있습니다.가장 아름다운 하나의 답이 존재한다. 앞의 명제는 파이썬의 모토이며 이와 같은 대 명제를 토대로 다음과 같은 철학을 지니게 되었습니다. 아름다운 것이 추한 것보다 낫다. 명시적인 것이 암시적인 것보다 낫다. 간결한 것이 복잡한 것보다 낫다. 정교한 것이 난잡한 것보다 낫다. 저는 이와 같은 디자인 철학에 백퍼센트 동의하진 않지만, 복잡하지 않으면서 명확하고, 심플한 파이썬스러움은 파이썬을 사용하기에 충분히 매력적으로 다가 왔습니다. 파이썬스러움(pythonic)한 코드를 짜기 위한 몇가지 규칙이 정의 되어있는데 PEP8 이라는 코드 스타일 규정이 존재합니다. PEP 8 – Style Guide for Python Code파이썬 코딩 컨벤션이러한 아름다움과 간결한 문법 덕분에 파이썬은 배우기 쉬우며, 높은 가독성을 제공합니다. 덕분에 C, C++, JAVA 같은 언어로 개설 되던 대학 수업들이 Python으로 옮겨 가는 추세입니다. 우리나라 대학 중에는 연세대, 카이스트, 부산대, 국민대, 인천대에서 이미 프로그래밍 개론 수업을 Python으로 진행하고 있습니다. 반복 가능한 객체프로그래머에게 조건문과 반복문은 컴퓨터와 소통하는 가장 중요한 도구 중 하나에 속합니다. 파이썬에는 반복 가능한 객체(iterable)가 존재하는데, 기존의 반복문이 청동무기 였다면 철무기쯤으로 업그레이드 시켜줍니다. 이 객체는 집합, 문자열, 튜플, 딕셔너리, 그리고 함수 등 iterable한 모든 객체를 의미합니다. 이뿐만 아니라 반복 가능한 객체에는 헬퍼 메소드가 존재하여 생산성 또한 증가시킵니다. 특히 함수의 반복은 큰 장점이 됩니다. 아래 작성한 코드를 보시고 어느 로직에 응용할 수 있을지 생각해보세요~. 1234567891011121314def multiple(n): x = 1 while 1: yield n*x x += 1f = factorial(10)# print(f.__next__()) # 10# print(f.__next__()) # 20# print(f.__next__()) # 30print(next(f)) # 10print(next(f)) # 20print(next(f)) # 30 위 코드의 프린트 값을 보면 함수가 값을 리턴했음에도 함수 내부 환경이 유지 됩니다. 자바스크립트를 공부하신 분이라면 클로져가 떠오를 수도 있겠지요. Anyway 위 함수가 종료되기 전까지 지역변수를 유지합니다. 결국 위의 함수의 계속 호출한다면 값은 지속적으로 증가하겠지요? 만능 언어최근의 언어트렌드는 높은 생산성과 만능언어가 아닐까 생각합니다. 물론 분야마다 차이는 존재하지만 명백한 사실입니다. 인기도를 측정해볼 수 있는 척도중 하나인 Stack Over Flow의 언어 카테고리당 질문율을 살펴보면 정확한 수치도 확인할 수 있습니다.2016 Stack overflow - Developer Survey Results그렇다면 파이썬은 어떤면 때문에 만능언어일까요? 첫번째, 이유는 Python으로 공급되는 다양한 분야의 방대한 패키지입니다.궁금하신분은 아래 사이트를 참고하세요.PyPL Ranking 두번째, 다양한 자료구조와 글루언어(다른언어와 접착성)로서의 역할 입니다.이 부분을 언급하기전에 파이썬의 단점 하나를 집고 넘어가자면 속도입니다. 실행환경에서 타입을 설정하는 언어의 특성상 느릴수 밖에 없지만, 다른 동적 언어들(JavaScript, LISP …)과 비교해봐도 속도가 빠른편은 아닙니다. 하지만 다른언어들(C, JAVA 등 메인언어)과의 높은 결합성 덕분에 속도적인 이슈가 있는 부분은 C로 작성하고, 생산성이 중요한 부분은 Python으로 작성한다면 속도 이슈를 해결할 수 있습니다. 특히, Python 자체가 C로 구현되었기 때문에 C와 궁합이 잘 맞는다고 합니다. 결론저에게 파이썬은 아릅답습니다. 배우기 쉽고, 간결하며 높은 생산성을 갖고 있습니다. 그렇지만 파이썬 언어도 결국은 프로그래머의 하나의 도구에 불과합니다. 단순히 프로그래밍을 할 수 있는 것과 좋은 프로그래밍을 하는 것은 하늘과 땅 차이입니다. 결국 프로그래밍의 수준은 언어가 아닌 프로그래머의 역량입니다. 결론적으로 프로그래밍 자체를 아릅다게 하기 위해서는 언어에 상관없이 프로그래밍 자체를 공부해야 합니다. 알고리즘, 디자인패턴, 아키텍처, 테스트기법, 동시성, 자료구조 등의 필요한 지식을 유기적으로 이해할 수 있다면 어떤 언어를 사용하더라도 아름다운 프로그래밍을 할 수 있는 개발자가 될 것이라 생각합니다. PS. 부족한 하거나 잘 못된 부분에 대한 지적은 감사히 받겠습니다. 부족한 글 끝까지 읽어주셔서 감사합니다. Reference점프 투 파이썬 : Python의 기본을 쉽게 익히기에 좋은 사이트파이썬 - 위키백과파이썬 - 나무위키rochan87@gmail.com 필자의 머릿속. Related Posts","categories":[{"name":"Python","slug":"Python","permalink":"https://selo77.github.io/categories/Python/"},{"name":"Language","slug":"Python/Language","permalink":"https://selo77.github.io/categories/Python/Language/"}],"tags":[{"name":"python","slug":"python","permalink":"https://selo77.github.io/tags/python/"}]}]}