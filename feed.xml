<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SELO&#39;s Autobiography</title>
  <subtitle>SELO&#39;s LOG</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://selo77.github.io/"/>
  <updated>2016-10-03T17:14:07.000Z</updated>
  <id>https://selo77.github.io/</id>
  
  <author>
    <name>SELO77</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python -  == 와 is 의 차이</title>
    <link href="https://selo77.github.io/2016/10/04/python-deference-is-and-equal/"/>
    <id>https://selo77.github.io/2016/10/04/python-deference-is-and-equal/</id>
    <published>2016-10-03T15:04:18.000Z</published>
    <updated>2016-10-03T17:14:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python은 직관적이고 하이레벨 프로그래밍 언어입니다. 이에 맞게 우리가 쓰는 언어에 가까운 문법이 존재합니다. 그 중에 오늘은 is 와 == 의 차이를 공부해보겠습니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>things = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>things[:]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>things == things[:]</span><br><span class="line">Ture</span><br></pre></td></tr></table></figure>
<p>things와 things[:] 값을 비교하였고, True를 반환 받았습니다. 그렇다면 is를 사용하여 한번더 비교해보겠습니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>things <span class="keyword">is</span> things[:]</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>리턴값이 False 입니다. is 와 == 을 이해하고 사용하시는 분이라면 당연한 결과라 말씀하시겠지만 Python을 사용하여 돈을 벌고 있음에도 불구하고 저는 문제를 마딱드리기 전까지 차이를 모르고 사용했습니다. 물론 직관적으로 어느 부분에 is를 사용하고  ==을 사용해야 할지 판단했기때문에 문제(버그)에 직면하지 않았습니다. 갑자기 “똥인지 된장인지 구분못하고 쓰면안된다” 는 저의 개발 스승님 말씀이 떠오르네요…</p>
<p>위 결과값의 차이를 보니 확실히 is 와 == 이 뭔가는 다른것 같습니다. 그렇다면 무엇이 다를까요? 이를 확인하기 위해 어떤 방법을 동원해볼까요?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="keyword">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name <span class="keyword">is</span> <span class="keyword">None</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name == <span class="keyword">None</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>이번에는 둘다 같은 True를 반환했네요. 그렇다면 첫번째 주어진 조건과 두번째 조건의 차이를 알수 있다면, is 와  == 의 차이를 알수 있을것 같은 느낌이 드네요.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(things)</span><br><span class="line"><span class="number">4556601824</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(things[:])</span><br><span class="line"><span class="number">4556641344</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(name)</span><br><span class="line"><span class="number">4554182552</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(<span class="keyword">None</span>)</span><br><span class="line"><span class="number">4554182552</span></span><br></pre></td></tr></table></figure>
<p>파이썬에 내장 함수인 id()를 이용해 메모리상의 주소값을 비교해보았습니다. 결과값을 보니 is 와 == 의 차이가 뭔지 아시겠나요?</p>
<p>첫번째 소스의 things 와 things[:] 를 is 로 비교했을때 False를 반환했던 이유는 객체의 주소가 달랐기 때문입니다. things의 주소는  4556601824 이고, things[:] 는 4556641344 입니다. 공부를 하면서 얻은 보너스!!! [:] 처리는 Call by value 가 아니라 Call by Reference 처리라는 것도 알 수 있습니다.</p>
<p>정리하자면 Python에서 == 는 Value를 자체를 비교하는 연산자 이고, is 는 객체의 주소(object identity)를 비교하는 키워드 혹은 비교연산자라는 것을 알수있습니다.</p>
<p>오늘 공부 끝~! 부족한글 읽어주셔서 감사합니다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://stackoverflow.com/questions/14247373/python-none-comparison-should-i-use-is-or" target="_blank" rel="external">Python None comparison: should I use “is” or ==?</a><br><em>
</em></li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다. 포스팅의 첫번째 목적은 작성자의 학습이므로 Context가 틀어지는 경우가 있을수 있씁니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python은 직관적이고 하이레벨 프로그래밍 언어입니다. 이에 맞게 우리가 쓰는 언어에 가까운 문법이 존재합니다. 그 중에 오늘은 is 와 == 의 차이를 공부해보겠습니다.&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;ta
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Language" scheme="https://selo77.github.io/categories/Python/Language/"/>
    
    
      <category term="python" scheme="https://selo77.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python Regex by re module (파이썬 정규식 활용)</title>
    <link href="https://selo77.github.io/2016/09/25/python-regex/"/>
    <id>https://selo77.github.io/2016/09/25/python-regex/</id>
    <published>2016-09-24T17:14:52.000Z</published>
    <updated>2016-10-03T15:01:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="정규식은-왜-필요한가"><a href="#정규식은-왜-필요한가" class="headerlink" title="정규식은 왜 필요한가?"></a>정규식은 왜 필요한가?</h2><p>정규식은 문자열 파싱을 위해 존재합니다. 정규식이 없어도 문자열 파싱은 가능합니다. 하지만 정규식은 복잡한 파싱을 혁신적으로 간단하게 만들어줍니다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ul>
<li>특정한 규칙을 가진 집합을 표현</li>
<li>문자열의 검색이나 치환에 편리.</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.youtube.com/watch?v=kWyoYtvJpe4" target="_blank" rel="external">Google Python Class Day 2 Part 1:Regular Expressions.</a></li>
<li><a href="https://www.youtube.com/watch?v=pkcTEoUexag&amp;list=PLZPhyNeJvHRnSJ2sAnqCGFnVRKo98EgCp&amp;index=4" target="_blank" rel="external">Regular expression [A-Z]+ - PyCon APAC 2016 - 양민지</a></li>
<li><a href="https://wikidocs.net/1642" target="_blank" rel="external">점프 투 파이썬</a></li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다. 포스팅의 첫번째 목적은 작성자의 학습이므로 Context가 틀어지는 경우가 있을수 있씁니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2><a href="/2016/06/23/Python-definition/" title="Python - Python?">Python - Python?</a>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;정규식은-왜-필요한가&quot;&gt;&lt;a href=&quot;#정규식은-왜-필요한가&quot; class=&quot;headerlink&quot; title=&quot;정규식은 왜 필요한가?&quot;&gt;&lt;/a&gt;정규식은 왜 필요한가?&lt;/h2&gt;&lt;p&gt;정규식은 문자열 파싱을 위해 존재합니다. 정규식이 없어도 
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Language" scheme="https://selo77.github.io/categories/Python/Language/"/>
    
    
      <category term="Python" scheme="https://selo77.github.io/tags/Python/"/>
    
      <category term="Regex" scheme="https://selo77.github.io/tags/Regex/"/>
    
      <category term="RegularExpression" scheme="https://selo77.github.io/tags/RegularExpression/"/>
    
  </entry>
  
  <entry>
    <title>Python datetime module(class datetime, timedelta ...)</title>
    <link href="https://selo77.github.io/2016/09/02/python-datetime-strftime-example/"/>
    <id>https://selo77.github.io/2016/09/02/python-datetime-strftime-example/</id>
    <published>2016-09-02T02:49:32.000Z</published>
    <updated>2016-09-04T07:38:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="들어가기전에"><a href="#들어가기전에" class="headerlink" title="들어가기전에"></a>들어가기전에</h2><p>파이썬으로 하는 개발이 즐거운 이유중 하나는 강력한 내장 모듈입니다. 3.3부터 추가된 asyncio(제가 가장 좋아하는 모듈입니다.)!! 혹은 multiprocessing, logging, sys, os 등등등 왠만해서는 3rd Library 필요없이 구현이 가능합니다. 오늘은 이런 강력한 모듈 중 하나인 datetime에 관하여 살펴보겠습니다.</p>
<p>날짜와 시간 처리는 개발자에게 상당한 고민을 요구합니다. 특히 글로벌 서비스의 경우는 시간대 설정이 매우 종요합니다. 서비스 하는 국가가 섬머타임 정책까지 사용한다면 ??? 나ㅣ어ㅣ만어ㅣ만어ㅣ ㅇㅇ아ㅣ너ㅣㅏㄴ어리ㅓㅏ !!!!!! 하지만 걱정안하셔도 됩니다. 이미 똑똑한 선구자들께서는 이미 우리를 위해 길을 만들어 놓으셨답니다.</p>
<h2 id="datetime-Objects"><a href="#datetime-Objects" class="headerlink" title="datetime Objects"></a>datetime Objects</h2><p>datetime 모듈은 모듈 이름 그대로 날짜와 시간의 조작에 관한 거의 모든 기능을 제공합니다. 구구절절 설명 보다는 코드를 보면서 살펴봅시다~. 아래 코드는 기록을 위해 texteditor를 사용하였습니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> type(datetime) <span class="comment"># module</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> datetime(year=<span class="number">2016</span>, month=<span class="number">10</span>, day=<span class="number">23</span>) <span class="comment"># 2016-10-23 00:00:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def __init__(self, year, month, day, hour=None, minute=None, second=None, microsecond=None, tzinfo=None): # real signature unknown; restored from __doc__</span></span><br></pre></td></tr></table></figure>
<p>먼저 말씀드렸다 싶이 datetime 자체는 모듈 패키지로서, 다양한 Class를 갖고 있습니다. 그 중 핵심이 되는 class datetime를 기반으로 다양한 연산과 활용이 가능하답니다.( module datetime 과 class datetime이 이름이 똑같은 이유는 아마도 이러한 이유가 아닐까 생각합니다. ) datetime의 생성자를 살펴보면 기본적으로 년, 월, 일 3가지 인자를 initial value를 인자로 받아 상태값을 셋팅합니다. 여기서 중요한 부분은 tzinfo=none 입니다. 제가 현재 일하는 회사에서는 30개국을 대상으로 서비스를 진행하는데, 국가에 따라 tzinfo를 설정 따로 GMT +A 를 계산할 필요가 없습니다.(서머타임 예외) <strong>Key point: datetime모듈의 핵심 클래스는 class datetime이다. Why? datetime모듈을 사용은 단순히 날짜와 시간을 확인하기 보다는 날짜와 시간 연산을 위해 사용하는 경우가 대부분입니다. 그렇기에 datetime 객체는 연산을 위한 핵심 type 입니다. type이 정확하지 않은 경우 TypeError를 맞이하겠죠!</strong></p>
<p>아래에서는 제가 주로 사용하는 datetime의 메소드를 살펴보겠습니다.</p>
<h3 id="strptime-과-strftime"><a href="#strptime-과-strftime" class="headerlink" title="strptime() 과 strftime()"></a>strptime() 과 strftime()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybirthday_str = datetime.strftime(mybirthday_datetime, <span class="string">"%Y/%m/%d %H:%M:%S"</span>)</span><br><span class="line"><span class="keyword">print</span> mybirthday_str <span class="comment"># 1987/04/13 00:00:00</span></span><br><span class="line"><span class="keyword">print</span> type(mybirthday_str) <span class="comment"># &lt;type 'str'&gt;</span></span><br></pre></td></tr></table></figure>
<p>strftime() 은 datetime object와 format(날짜형식)을 입력 받아, 입력받은 format에 맞는 string object로 반환해줍니다. 이와 반대로 strptime()은 string object와 format을 입력 받아 datetime object로 캐스팅 해줍니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">now_str = <span class="string">"2016-09-02 21:31:30"</span></span><br><span class="line">now_datetime = datetime.strptime(now_str, <span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line"><span class="keyword">print</span> type(now_datetime) <span class="comment"># &lt;type 'datetime.datetime'&gt;</span></span><br></pre></td></tr></table></figure>
<p>하지만 여기서 끝난다면 파이썬 내장모듈이라기에 약한 느낌이죠?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> datetime.strftime(now_datetime, <span class="string">"%y %B %A %p %I/ week number of the year: %W"</span>)</span><br><span class="line"><span class="comment"># 16 September Friday PM 09/ week number of the year: 35</span></span><br></pre></td></tr></table></figure>
<p>위와 같이 다양한 Directive로 데이터를 표현할 수도 있답니다. 결론, 캐스팅 헬퍼 메소드의 구현 과정없이 내장 모듈을 사용하시면 되겠습니다!!<br>아 참고로 strftime()는 datetime 뿐만 아니라 date, time objects 모두 지원합니다.</p>
<p><a href="https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior" target="_blank" rel="external">Python API: strftime &amp; strptime </a></p>
<h2 id="timedelta-Objects"><a href="#timedelta-Objects" class="headerlink" title="timedelta Objects"></a>timedelta Objects</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">today_datetime = datetime.today()</span><br><span class="line"><span class="keyword">print</span> today_datetime <span class="comment"># 2016-09-02 22:38:09.543477</span></span><br><span class="line">one_weeks = timedelta(weeks=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># days=None, seconds=None, microseconds=None, milliseconds=None, minutes=None, hours=None, weeks=None</span></span><br><span class="line">one_weeks_ago = today_datetime - one_weeks</span><br><span class="line"><span class="keyword">print</span> one_weeks_ago <span class="comment"># 2016-08-26 22:38:09.543477</span></span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 timedelta Object를 사용하면 날짜 시간 연산을 직관적으로 해결할 수 있도록 도와줍니다.</p>
<h2 id="tzinfo-Objects"><a href="#tzinfo-Objects" class="headerlink" title="tzinfo Objects"></a>tzinfo Objects</h2><p>만약 제공하는 서비스가 우리나라로 국한된다면 tzinfo 오브젝트 까지 굳이 사용은 필요는 없습니다. 서버가 해외에 있는 경우는 조금 다르지만… 하지만 글로벌 서비스를 하거나 특정 timezone 구현이 필요하다면 !!! tzinfo objects를 활용하면 원하는 timezone objects를 만들어 사용할수 있습니다.</p>
<h2 id="date-time-Objects"><a href="#date-time-Objects" class="headerlink" title="date, time Objects"></a>date, time Objects</h2><p>위 Objects 이외에도 date, time Objects가 존재하지만 저같은 경우는 datetime Objects로 대부분 처리 함으로 이 Objects에 대한 설명은 생략하도록 하겠습니다. 원하시는 분은 아래 Reference의 datetime module API를 살펴보시기 바랍니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>datetime module에는 정말 많은 기능들이 내장되어 있습니다. 잘찾아 잘쓰시면 됩니다….!!<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line"><span class="keyword">print</span> now <span class="comment"># 2016-09-04 16:33:11.164451</span></span><br><span class="line"></span><br><span class="line">now_date = now.date()</span><br><span class="line"><span class="keyword">print</span> now_date <span class="comment"># 2016-09-04</span></span><br><span class="line"><span class="keyword">print</span> type(now_date) <span class="comment"># &lt;type 'datetime.date'&gt;</span></span><br><span class="line"></span><br><span class="line">now = now.replace(year=<span class="number">2000</span>)</span><br><span class="line"><span class="keyword">print</span> now <span class="comment"># 2000-09-04 16:35:03.646963</span></span><br><span class="line"></span><br><span class="line">d = datetime.date(<span class="number">1987</span>, <span class="number">04</span>, <span class="number">13</span>)</span><br><span class="line">t = datetime.time(<span class="number">01</span>, <span class="number">01</span>, <span class="number">59</span>)</span><br><span class="line"></span><br><span class="line">dt = datetime.datetime.combine(d, t)</span><br><span class="line"><span class="keyword">print</span> dt</span><br><span class="line"></span><br><span class="line">dt_tuple = dt.timetuple()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dt_tuple:</span><br><span class="line">  <span class="keyword">print</span> i</span><br><span class="line">  <span class="comment"># 1987</span></span><br><span class="line">  <span class="comment"># 4</span></span><br><span class="line">  <span class="comment"># 13</span></span><br><span class="line">  <span class="comment"># 1</span></span><br><span class="line">  <span class="comment"># 1</span></span><br><span class="line">  <span class="comment"># 59</span></span><br><span class="line">  <span class="comment"># 0</span></span><br><span class="line">  <span class="comment"># 103</span></span><br><span class="line">  <span class="comment"># -1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://overapi.com/python" target="_blank" rel="external">overapi/python</a></li>
<li><a href="https://docs.python.org/2/library/datetime.html" target="_blank" rel="external">python module datetime api</a></li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다. 포스팅의 첫번째 목적은 작성자의 학습이므로 Context가 틀어지는 경우가 있을수 있씁니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2><a href="/2016/06/23/Python-definition/" title="Python - Python?">Python - Python?</a>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;들어가기전에&quot;&gt;&lt;a href=&quot;#들어가기전에&quot; class=&quot;headerlink&quot; title=&quot;들어가기전에&quot;&gt;&lt;/a&gt;들어가기전에&lt;/h2&gt;&lt;p&gt;파이썬으로 하는 개발이 즐거운 이유중 하나는 강력한 내장 모듈입니다. 3.3부터 추가된 async
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Language" scheme="https://selo77.github.io/categories/Python/Language/"/>
    
    
      <category term="python" scheme="https://selo77.github.io/tags/python/"/>
    
      <category term="datetime" scheme="https://selo77.github.io/tags/datetime/"/>
    
      <category term="strftime" scheme="https://selo77.github.io/tags/strftime/"/>
    
      <category term="strptime" scheme="https://selo77.github.io/tags/strptime/"/>
    
  </entry>
  
  <entry>
    <title>자료구조 기본 - 배열, 리스트, 스택, 큐, 트리, 그래프</title>
    <link href="https://selo77.github.io/2016/08/20/basic-datastructure/"/>
    <id>https://selo77.github.io/2016/08/20/basic-datastructure/</id>
    <published>2016-08-20T05:06:08.000Z</published>
    <updated>2016-08-21T09:11:07.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="자료구조-개념-정의"><a href="#자료구조-개념-정의" class="headerlink" title="자료구조 개념 정의"></a><strong>자료구조 개념 정의</strong></h2><p>이번 포스팅은 가장 흔히 접할 수 있는 자료구조에 대해 한줄 정리를 하는 간단한 포스팅이 될 예정입니다.</p>
<p>먼저 자료구조의 정의에 대해 간단히 집고 넘어가자면,</p>
<blockquote>
<p>자료구조(資料構造, 영어: data structure)는 전산학에서 자료를 효율적으로 이용할 수 있도록 컴퓨터에 저장하는 방법이다.<br>출처 : [위키피디아 - 자료구조]: <a href="https://ko.wikipedia.org/wiki/자료_구조" target="_blank" rel="external">https://ko.wikipedia.org/wiki/자료_구조</a></p>
</blockquote>
<p>대량의 데이터를 효율적으로 관리하는 메커니즘이며, 현실 세계에서의 우편번호나 학교에서 학생번호가 대표적인 예가 될 수 있습니다.</p>
<p>예를 들면 학생이 1000명 있는 학교에서 특정 학생을 이름으로 찾으려면 최소 1회 최대 1000회의 노력이 들어갑니다. 하지만 우리는 이런 방식으로 학생을 찾지 않습니다. 1학년 2반 3번 이새로찬 이런식으로 찾게 됩니다. 어떤 학생이든 3회만에 찾을 수 있는 조건이 만들어 지게됩니다. 이렇듯 대량의 데이터를 효율적으로 관리하는 방식을 자료구조라 합니다.</p>
<p>컴퓨터에는 다양한 방식의 자료구조들이 존재하며, 프로그래밍 언어마다 내장된 기본 자료구조도 다릅니다. 그럼 이제 기본적인 자료구조를 살펴보러 가시죠. Here we go~!!</p>
<hr>
<h2 id="자료구조-종류-및-기본-개념"><a href="#자료구조-종류-및-기본-개념" class="headerlink" title="자료구조 종류 및 기본 개념"></a><strong>자료구조 종류 및 기본 개념</strong></h2><h3 id="배열"><a href="#배열" class="headerlink" title="배열"></a><strong>배열</strong></h3><p>컴퓨터 프로그래밍을 시작하면서 가장 먼저 접하게 되는 자료구조입니다. 배열은 데이터가 일직선상에 빈틈없이 나열한 자료구조 입니다. 여기서 키포인트는 빈틈없이 나열되 었다는 점입니다. 배열과 리스트를 헷갈려하시는 분들이 있는데 이 부분은 리스트에서 추가 설명드리겠습니다.<br><img src="https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcTzU4dUSHmTVAun3GaQMfX3fLZWJdgxbGIu9uxtWOGSrCXT5yzkw1b6Ku0"></p>
<h3 id="리스트"><a href="#리스트" class="headerlink" title="리스트"></a><strong>리스트</strong></h3><p>데이터가 순차적으로 나열된 자료구조 입니다. 배열과 같이 나열된 데이터를 관리 한다는 부분에서 혼란을 줍니다. 하지만 배열과 리스트의 그림을 보면서 이해하면 차이점이 좀 더 명확히 이해되실겁니다. 배열은 나열된 데이터를 인덱스(쉽게 설명하자면 박스의 이름)으로 데이터를 색인(검색) 가능하다면 리스트는 포인터(쉽게 생각하자면 연결 빨대)로 서로 연결되 있으며, 포인터(연결 빨대)를 통해 검색이 이루어 질 수 있습니다. 그럼 한 가지 질문을 드리자면 <strong>특정 Index(위치)를 검색할때 배열과 리스트 중 어느 자료구조의 평균 검색속도가 빠를까요?</strong></p>
<p><img src="http://cfile3.uf.tistory.com/image/1338A04A4F9948D9378E81"></p>
<h3 id="스택"><a href="#스택" class="headerlink" title="스택"></a><strong>스택</strong></h3><p>스택 == 쌓다. 단어 뜻 그대로 쌓이는 자료구조입니다. 스택의 경우는 크게 두가지 액션을 갖는데 푸쉬와 팝입니다. 말그대로 데이터를 푸쉬 집어넣고, 팝 꺼냅니다. 이게 다입니다!! 먼저 들어간 데이터가 가장 나중에 나오게 되는 스택(<strong>FILO</strong>: FIRST IN, LAST OUT.). 자료구조는 어느 곳에 사용하면 효율적일까요?<br><img src="http://1.bp.blogspot.com/-L-wZpwPSGfw/UI79Cpd_iMI/AAAAAAAAAw8/25VRkQU7fgc/s1600/s.png"></p>
<h3 id="큐"><a href="#큐" class="headerlink" title="큐"></a><strong>큐</strong></h3><p>큐는 스택과 반대되는 개념으로 1차선 터널을 생각하시면 됩니다. 1차선 터널에서 먼저 들어간 차가 먼저 나오게 될 것입니다.(<strong>FIFO</strong>: FIRST IN, FIRST OUT) 이러헌 큐(대기행렬)는 어떤 데이터 관리에 효율적일까요?</p>
<p><img src="http://cfile28.uf.tistory.com/image/26606738537BF2F836AF58"></p>
<h3 id="이진-트리"><a href="#이진-트리" class="headerlink" title="이진 트리"></a><strong>이진 트리</strong></h3><p>이진트리는 다음 요소(노드)를 가리키는 포인트를 2개 갖는 단방향 리스트의 일종이라고 할 수 있습니다. 상위노드를 부모노드 라 하며 하위노드를 자식노드라 합니다. 가장 최상위 노드를 뿌리라 하며 최하위 노드를 잎(리프)라고 부릅니다.<br><img src="http://cfile6.uf.tistory.com/image/2321CB4951A467AC0B97C5"></p>
<ul>
<li><strong>힙(HEAP)</strong> - 부모노드의 값이 자식노드의 값보다 항상 작은(또는 항상 큰) 규칙을 갖는 이진 트리를 힙이라 합니다.</li>
</ul>
<h3 id="그래프"><a href="#그래프" class="headerlink" title="그래프"></a><strong>그래프</strong></h3><p>마지막 그래프입니다. 기본적으로 그래프는 아래그림에서 보시다 시피 각항 목을 의미하는 정점(노드)와 정점의 관계를 표현하는 간선으로 구성된 자료구조입니다. 한 마디로 데이터의 관계를 노드와 엣지로 표현한 자료구조입니다. 검색 시스템에서 많이 사용되는 자료구조입니다. 간단히 설명하자면 검색단어를 검색하고, 검색단어에 해당하는 노드에 연결된 노드들을 이어주는 간선의 가중치나 관계를 파악함으로서 검색결과를 다양하게 뽑아낼수 있게됩니다.</p>
<p><img src="http://cfile9.uf.tistory.com/image/172F48394F0A45181824C0"></p>
<hr>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>사실 자료구조만 띡!! 놓고 학습하면 생각보다 각각의 자료구조들이 어디에 사용되고 사용해야할지 의문이 많이듭니다. 그래서 저는 이를 학습하는 방법으로 자료구조를 직접 구현해볼 예정입니다. 사실 저에게 자료구조와 알고리즘 학습은 많은 인내를 요구합니다. 대부분의 다른분들도 그러리라 생각됩니다. 하지만 앞선 포스팅 <a href="/2016/08/11/datastructure-basic/" title="자료구조 알고리즘은 꼭 필요한 것인가?">자료구조 알고리즘은 꼭 필요한 것인가?</a> 의 정신을 다시한번 되세기며 자료구조와 알고리즘을 내 코딩에 자연스럽게 녹여내는 날까지. 화이팅입니다!!</p>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>책 - <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=10741278" target="_blank" rel="external">그림으로 배우는 알고리즘 Basic</a></li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<hr>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2><a href="/2016/08/11/datastructure-basic/" title="자료구조 알고리즘은 꼭 필요한 것인가?">자료구조 알고리즘은 꼭 필요한 것인가?</a>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;자료구조-개념-정의&quot;&gt;&lt;a href=&quot;#자료구조-개념-정의&quot; class=&quot;headerlink&quot; title=&quot;자료구조 개념 정의&quot;&gt;&lt;/a&gt;&lt;strong&gt;자료구조 개념 정의&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;이번 포스팅은 가장 흔히 접할
    
    </summary>
    
      <category term="Base" scheme="https://selo77.github.io/categories/Base/"/>
    
      <category term="Algorithm" scheme="https://selo77.github.io/categories/Base/Algorithm/"/>
    
    
      <category term="Stack" scheme="https://selo77.github.io/tags/Stack/"/>
    
      <category term="Queue" scheme="https://selo77.github.io/tags/Queue/"/>
    
      <category term="Graph" scheme="https://selo77.github.io/tags/Graph/"/>
    
      <category term="Datastructure" scheme="https://selo77.github.io/tags/Datastructure/"/>
    
      <category term="Binary Tree" scheme="https://selo77.github.io/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>자료구조 알고리즘은 꼭 필요한 것인가?</title>
    <link href="https://selo77.github.io/2016/08/11/datastructure-basic/"/>
    <id>https://selo77.github.io/2016/08/11/datastructure-basic/</id>
    <published>2016-08-11T07:46:18.000Z</published>
    <updated>2016-08-20T05:48:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="자료구조-알고리즘은-꼭-필요한-것인가"><a href="#자료구조-알고리즘은-꼭-필요한-것인가" class="headerlink" title="자료구조 알고리즘은 꼭 필요한 것인가?"></a>자료구조 알고리즘은 꼭 필요한 것인가?</h2><p>저는 사파 개발자 입니다. 제가 정의한 사파 개발자라함은 비전공자로서 체계적인 학습을 받지 못한 상태에서 개발에 입문한 개발자를 말합니다. 사실 사파와 정파를 나누다는 것 자체가 제 자신이 부족하다는 증거일 것입니다. 하지만 주니어 개발자 단계에서는 사파와 정파의 차이는 분명 존재합니다. 특히 기반지식들에서는 큰 차이와 출발지점 자체가 다릅니다. 그 중 자료구조와 알고리즘은 무림에 갓 입문한 사파 개발자에게 아주 큰 벽이자 애증의 관계입니다. 그 대표로 제 자신이 존재합니다.</p>
<p>제 경험을 빗대어 얘기해보자면, 회사에서 신규 서비스를 개발할 때 2명의 API 개발자 중 한명으로 투입된 적이 있었습니다. 지금도 입문자 수준이지만 이 당시에는 알고리즘과 자료구조에 대한 지식이 전무했습니다. 하지만 3개월의 개발기간 동안 문제 없이 개발을 진행했고, 오픈까지 성공적으로 완수 했습니다.</p>
<p>‘그래서 너가 하고 싶은 말이 뭐냐?’</p>
<p>음 뭐냐면요… 복잡한 알고리즘이 필요 없는 서비스에서는 자료구조와 알고리즘에 대한 이해가 크게 중요하지 않습니다. 특히 트래픽이 폭팔적으로 많지 않다면 남아도는 서버의 자원이 있다면 더더욱 중요하지 않습니다. 오히려 이 단계에서는 알고리즘과 자료구조에 대한 이해 보다는 코드의 재사용성에 대한 이해와 가독성이 훨씬 중요할 것이라 생각됩니다.</p>
<p>‘뭐지 이 자식 지는 자료구조와 알고리즘에 대해 포스팅하고 있으면서 왜 자꾸 필요없다는 말을 하는거지?!! 뭐 어쩌라고?!’</p>
<p><strong>어느 정도 수준의 서비스는 자료구조와 알고리즘이 이해 없이도 꾀 잘 만들수 있다는 믿음은 변함없습니다. 어느 정도로 잘 만들어진 제품을 100점 만점에 80점이라 가정했을 때, 자신이 받은 점수가 80점으로 만족하는 개발자라면 자료구조와 알고리즘을 굳이 공부할 필요가 없다 생각합니다. 80점을 만드는 개발자가 나쁜 것이 아닙니다. 어느 상황에서는 100점 보다 80점 제품이 기업에서 요구하는 수준일 수 있습니다. 60점을 80점으로 만드는 비용과 80점을 100점으로 향상시키는 비용은 비교가 되지 않을 만큼 더 클 것이기 때문입니다. 학창시절 만점을 맞기 위해 투자하는 노력과 80점을 맞기 투자한 노력의 차이와 같은 맥락일 것입니다.</strong></p>
<p>결국 본인이 80점 이상의 제품을 만들기 원하는 기업에 들어가고 싶다거나 본인 스스로 80점이상의 제품을 만들고 싶다면 자료구조와 알고리즘과 같은 기초지식?들이 필요합니다.</p>
<p>서론이 엄청 길었네요… 자료구조와 알고리즘과 오랜 싸움을 위해서 어느 정도의 동기부여와 각오가 제 스스로 필요했던 것 같습니다. <strong>사파든 정파든 개발자의 길을 선택했고, 100점 짜리 제품을 만들 수 있는 고수가 되기 위해서 저는 알고리즘과 자료구조를 공부합니다!!</strong> 주저리 끝!! 이제 공부하러 갑시다!!</p>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2><ul>
<li><a href="/2016/07/10/Algorithm-Algorithmic-Problem-Solving-Strategies-02Solving-Problem-Overview/" title="Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 02문제 해결 개관">Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 02문제 해결 개관</a></li>
<li><a href="/2016/07/10/Algorithm-Algorithmic-Problem-Solving-Strategies/" title="Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 01문제해결과 프로그래밍 대회">Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 01문제해결과 프로그래밍 대회</a>
</li>
</ul>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;자료구조-알고리즘은-꼭-필요한-것인가&quot;&gt;&lt;a href=&quot;#자료구조-알고리즘은-꼭-필요한-것인가&quot; class=&quot;headerlink&quot; title=&quot;자료구조 알고리즘은 꼭 필요한 것인가?&quot;&gt;&lt;/a&gt;자료구조 알고리즘은 꼭 필요한 것인가?&lt;/h2
    
    </summary>
    
      <category term="Base" scheme="https://selo77.github.io/categories/Base/"/>
    
      <category term="Algorithm" scheme="https://selo77.github.io/categories/Base/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://selo77.github.io/tags/Algorithm/"/>
    
      <category term="datastructure" scheme="https://selo77.github.io/tags/datastructure/"/>
    
      <category term="Array" scheme="https://selo77.github.io/tags/Array/"/>
    
      <category term="List" scheme="https://selo77.github.io/tags/List/"/>
    
      <category term="Stack" scheme="https://selo77.github.io/tags/Stack/"/>
    
      <category term="Queue" scheme="https://selo77.github.io/tags/Queue/"/>
    
      <category term="Tree" scheme="https://selo77.github.io/tags/Tree/"/>
    
      <category term="HashMap" scheme="https://selo77.github.io/tags/HashMap/"/>
    
      <category term="Graph" scheme="https://selo77.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>The Django Beginning (MVC Vs MTV)</title>
    <link href="https://selo77.github.io/2016/08/01/what-is-django/"/>
    <id>https://selo77.github.io/2016/08/01/what-is-django/</id>
    <published>2016-08-01T11:44:09.000Z</published>
    <updated>2016-08-03T13:53:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Django란"><a href="#Django란" class="headerlink" title="Django란?"></a>Django란?</h2><p>장고는 Python에서 사용하는 가장 대표적인 웹 프레임웍 입니다. 자바에 스프링, 루비에 레일스가 있다면 파이썬에는 그 이름도 특이한 <a href="https://www.djangoproject.com/" target="_blank" rel="external">장고</a>!! 가 존재합니다.</p>
<p>장고는 기본적으로 <a href="https://ko.wikipedia.org/wiki/%EB%AA%A8%EB%8D%B8-%EB%B7%B0-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC" target="_blank" rel="external">MVC Architecture pattern</a>을 따릅니다. MVC 패턴은 웹 프레임웍에서 가장 많이 체택되는 디자인 패턴중 하나로서 역할에 따른 소스 코드의 분리로 많은 장점들을 갖게 됩니다. 장고는 MTV(Model Template View)는 디자인 패턴을 따르지만 이는 MVC 패턴의 일부로 생각합니다. 그럼 먼저 장고의 기본 아키텍처를 보고 넘어가겠습니다.<br><img src="/2016/08/01/what-is-django/Django_mvc.png" alt="Django Basic Architecture" title="Django Basic Architecture"><br><img src="/2016/08/01/what-is-django/MVCBasic.jpg" alt="Spring MVC Architecture" title="Spring MVC Architecture"><br>첫번째 다이어그램은 장고의 MTV 패턴이 적용된 아키텍처이며, 아래는 Java Spring의 MVC 아키텍처 입니다. 사실 장고가 뭔지도 잘 모르는데 아키텍처를 먼저 보는 이유는 무작정 코드를 작성하는 것보다 아키텍처 다이어그램을 머리에 세기고, 코드를 작성하면 데이터 흐름을 어느 정도 이해할수 있기 때문입니다. 또한 세부적인 코드가 전체에서 어느 부분에 영향을 미치게 되는지 이해를 도와줍니다.</p>
<h2 id="MVC-Vs-MTV"><a href="#MVC-Vs-MTV" class="headerlink" title="MVC Vs MTV"></a>MVC Vs MTV</h2><p>MVC 와 Django MTV를 비교를 통해 정리해보겠습니다. 먼저 MVC부터 살펴 보면 데이터베이스와 interaction은 <strong>Model</strong> 에서 처리하고, Business Logic은 <strong>Controller</strong>, User Interface의 생성은 <strong>View</strong> 에서 각각 처리합니다. (위의 다이어그램과 함께) 전체적 흐름을 살펴보자면 Request에 해당하는 컨트롤러를 호출하고, 컨트롤러는 request의 응답에 필요한 데이터를 찾기 위해서 적절한 Model을 소환합니다!! 최종적으로 View를 호출 Model에서 얻은 데이터를 토대로 사용자에게 보낼 User Interface를 구성 후 Response를 보내게 됩니다.</p>
<p>그렇다면 장고의 MTV는 뭐가 다를까요? 뭐가 다르기에 MTV라고 부르는 것일까요? MTV는 MVC를 약간 수정한  패턴입니다. MTV의 <strong>Model</strong> 은 MVC Model과 같은 역할을 합니다. 데이터 베이스와 데이트 추출을 담당 합니다. Django는 기본적으로 <a href="http://debop.blogspot.kr/2012/02/orm-object-relational-mapping.html" target="_blank" rel="external">ORM(Object Relational Mapping)</a> 테크닉을 지원합니다. ORM방식의 지원으로 개발자는 SQL의 작성 작업의 대부분으로 부터 자유로워 지며, OOP 개발에 집중할 수 있게 도와줍니다.<br> <strong>View</strong> 는 MVC의 Controller와 같은 Business Logic을 처리합니다. 마지막으로 <strong>Template</strong> 은 Client에게 보여질 User Interface를 구현하며, Django Template은 스크립트 언어인 Python의 장점을 극대화 시킨 강력한 templating system을 제공합니다. Middleware, URL Resolver Template Loader 부분은 당장 구현이 필요한 부분은 아니므로 넘어가셔도 상관없습니다.</p>
<img src="/2016/08/01/what-is-django/jumpstart-django-42-728.jpg" alt="Django Basic Architecture" title="Django Basic Architecture">
<p>위 다이어그램의 데이터 흐름과 함께 MTV 각각의 역할을 생각하시면 전체적인 그림이 그려지실 겁니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>파이썬의 강력한 웹 프레임웍 장고에 대해 살펴보았습니다. 장고는 MVC 패턴의 장점을 살리면서 빠른 생산을 위한 MTV 패턴을 채택하였습니다. 또한 ORM 테크를 지원하여 객체지향적인 코드 생산에만 전념할 수 있도록 도와줍니다. 또한 위에서 설명하지는 않았지만 깊은 역사?와 함께 수많은 지원 패키지들이 존재합니다. 이러한 수많은 장점 덕분에 스타트업에서 선호하는 웹 프레임웍 중 탑 순위권 안에 들었으며, 점점 더 많은 채택을 받으며 발전하고 있습니다. 아직은 어렵게 다가올수 있지만, 장고 프레임웍 하나만 제대로 이해해도 먹고 사는데는 지장이 없으리라 생각됩니다 흐흐.</p>
<p>Ps. 아마도 다음 포스팅은 장고 공식 사이트의 튜토리얼을 통해 간단한 여론조사 어플리케이션을 만들어 볼 예정입니다~.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://bharatikunal.wordpress.com/2009/03/11/introduction-to-django/" target="_blank" rel="external">Introduction to Django</a></li>
<li><a href="https://docs.python.org/3/tutorial/modules.html#tut-packages" target="_blank" rel="external">more abount python packages</a></li>
<li><a href="https://devissue.wordpress.com/2015/02/01/pycharm%EA%B3%BC-%ED%95%A8%EA%BB%98-django%EC%99%80-restframework%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0/" target="_blank" rel="external">PyCharm과 함께 DJango와 RestFramework를 활용한 웹 사이트 구축하기</a></li>
<li><a href="http://pythoninreal.blogspot.kr/2013/12/virtualenv.html" target="_blank" rel="external">virtualenv를 사용하자 - 가상 개발환경 구축하기</a></li>
<li><a href="https://www.jetbrains.com/help/pycharm/2016.1/adding-existing-virtual-environment.html" target="_blank" rel="external">Adding Existing Virtual Environment on PyCharm</a></li>
<li><a href="https://docs.djangoproject.com/en/1.10/misc/design-philosophies/#dry" target="_blank" rel="external">Django Design philosophies</a></li>
<li><a href="http://www.javajigi.net/pages/viewpage.action?pageId=6560" target="_blank" rel="external">ORM의 기본적인 개념 및 활용방안</a></li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<!-- ## Related Posts

<p><br/> –&gt;</p>
-->]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Django란&quot;&gt;&lt;a href=&quot;#Django란&quot; class=&quot;headerlink&quot; title=&quot;Django란?&quot;&gt;&lt;/a&gt;Django란?&lt;/h2&gt;&lt;p&gt;장고는 Python에서 사용하는 가장 대표적인 웹 프레임웍 입니다. 자바에 스프링, 루
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Django" scheme="https://selo77.github.io/categories/Python/Django/"/>
    
    
      <category term="python" scheme="https://selo77.github.io/tags/python/"/>
    
      <category term="Django" scheme="https://selo77.github.io/tags/Django/"/>
    
      <category term="MTV" scheme="https://selo77.github.io/tags/MTV/"/>
    
      <category term="MVC" scheme="https://selo77.github.io/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>python-asyncio-Tasks</title>
    <link href="https://selo77.github.io/2016/07/24/python-asyncio-Tasks/"/>
    <id>https://selo77.github.io/2016/07/24/python-asyncio-Tasks/</id>
    <published>2016-07-24T09:04:17.000Z</published>
    <updated>2016-07-24T09:07:01.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># asyncio Sample for MyMusicTaste</span></span><br><span class="line"><span class="comment"># SELO77</span></span><br><span class="line"><span class="comment"># 2016-07-24</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpwanClass</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @asyncio.coroutine</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self, request_class_list)</span>:</span></span><br><span class="line">    response = []</span><br><span class="line">    <span class="keyword">if</span> request_class_list:</span><br><span class="line"><span class="meta">      @asyncio.coroutine</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(request_class)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">          result = <span class="keyword">yield</span> <span class="keyword">from</span> request_class.execute()</span><br><span class="line">          response.append(result)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">          print(traceback.format_exc())</span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">        tasks_list = []</span><br><span class="line">        <span class="keyword">for</span> each_class <span class="keyword">in</span> request_class_list:</span><br><span class="line">          tasks_list.append(</span><br><span class="line">            asyncio.Task(run(each_class))</span><br><span class="line">          )</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.gather(*tasks_list)</span><br><span class="line">      <span class="keyword">except</span>:</span><br><span class="line">        print(traceback.format_exc())</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestClass1</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'RequestClass1.__init()__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">  @asyncio.coroutine</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"class1_response"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestClass2</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'RequestClass2.__init()__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">  @asyncio.coroutine</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"class2_response"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    request_class_list = [RequestClass1(), RequestClass2()]</span><br><span class="line">    spwanClass = SpwanClass()</span><br><span class="line">    final_result = <span class="keyword">yield</span> <span class="keyword">from</span> spwanClass.execute(request_class_list)</span><br><span class="line">    print(<span class="string">"final_result:%s"</span>%final_result)</span><br><span class="line">  <span class="keyword">except</span>:</span><br><span class="line">    print(traceback.format_exc())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>필자 머릿속</li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2><a href="/2016/07/05/Python-Asyncio/" title="Python- yield, generator, coroutine">Python- yield, generator, coroutine</a>
<a href="/2016/06/23/Python-definition/" title="Python - Python?">Python - Python?</a>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Language" scheme="https://selo77.github.io/categories/Python/Language/"/>
    
    
      <category term="python" scheme="https://selo77.github.io/tags/python/"/>
    
      <category term="asyncio" scheme="https://selo77.github.io/tags/asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Docker 란?</title>
    <link href="https://selo77.github.io/2016/07/19/What-is-Docker/"/>
    <id>https://selo77.github.io/2016/07/19/What-is-Docker/</id>
    <published>2016-07-18T22:47:23.000Z</published>
    <updated>2016-07-20T13:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://d21ii91i3y6o6h.cloudfront.net/gallery_images/from_proof/1026/large/1396373089/docker.png"></p>
<h2 id="Docker-란"><a href="#Docker-란" class="headerlink" title="Docker 란?"></a>Docker 란?</h2><p><strong>도커란 컨테이너(이미지)를 실행 관리하고 배포하기 위한 기술입니다.</strong> 범위를 좁게 하면 리눅스 컨테이너를 관리하는 도구입니다. 리눅스 컨테이너? 자바에서 서블릿컨테이너, JSP컨테이너는 들어봤는데 리눅스도 컨테이너가 있네요. 제가 알고 있는 컨테이너는 자바 빈들을 실행하고 관리 하기 위해 존재 했었는데요.</p>
<blockquote>
<p><a href="https://ko.wikipedia.org/wiki/LXC" target="_blank" rel="external">리눅스 컨테이너(LXC)란</a> 단일 컨트롤 호스타 상에서 리눅스 시스템(컨테이너)를 실행하기 위한 위한 운영 시스템 레벨 가상화 방법</p>
</blockquote>
<p>리눅스 컨테이너는 <a href="https://access.redhat.com/documentation/ko-KR/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch01.html" target="_blank" rel="external">Control Group(Cgroup)</a>와 <a href="http://bluese05.tistory.com/11" target="_blank" rel="external">namespace</a> 결합하여 애플리케이션을 위한 가상 환경을 제공합니다. Docker 또한 이러한 실행 환경을 갖게 되고 독립된 드라이버로서 작동할수 있게 됩니다. <strong>간단히 정리를 하자면 Docker는 Cgroup 기술로 Host OS 자원을 활용하고, namespace를 통해 독립된 실행 공간을 갖게 됩니다.</strong></p>
<h2 id="Docker-용어정리"><a href="#Docker-용어정리" class="headerlink" title="Docker 용어정리"></a>Docker 용어정리</h2><p>Docker(도커)의 개념을 이해했으면 Docker 내부적으로 사용되는 용어를 정리 해봅시다. 먼저 Docker의 환경의 전체적인 흐름을 살펴보실까요~</p>
<blockquote>
<p>도커 환경은 크게 도커 호스트와 도커 클라이언트로 생각해 볼 수 있습니다. 도커 호스트는 도커 데몬(도커 엔진?)을 기반으로 도커 컨테이너들을 실행 및 관리 합니다. 반면 도커 클라이언트는 도커 명령을 실행하는데 쉽게 이해하면 인터페이스로서 도커 이미지를 관리합니다.</p>
</blockquote>
<p>빠른 이해를 위해 기본 웹 환경과 대입해 이해해보겠습니다.</p>
<ul>
<li>도커 호스트는 도커 컨테이너를 실행하는 가상머신. (서버)</li>
<li>도커 클라이언트는 도커 Interface (클라이언트 프로그램)</li>
<li>도커 데몬은 도커 엔진 (서버 프로세스)</li>
<li>도커 컨테이너는 하나의 프로세스 (이미지의 인스턴스)</li>
<li>도커 이미지는 실행파일 (소스코드?)</li>
</ul>
<p>어느 정도 개념을 정리 했으니 도커 아키텍처를 보면서 구체화 시켜봅시다.</p>
<h2 id="Docker-Architecture"><a href="#Docker-Architecture" class="headerlink" title="Docker Architecture"></a>Docker Architecture</h2><ul>
<li><strong>간단한 Docker Architecture</strong><br><img src="http://southworks.com/blog/wp-content/uploads/sites/81/2015/07/docker_architecture.png"></li>
</ul>
<p><img src="http://nordicapis.com/wp-content/uploads/Docker-API-infographic-container-devops-nordic-apis.png"><br><br></p>
<ul>
<li><p><strong>기존의 가상머신 환경과 Docker의 차이</strong><br><img src="http://siliconangle.com/files/2014/08/Docker-vs-Virtualization.jpg"><br><br></p>
</li>
<li><p><strong>Docker Commands Diagram</strong><br><img src="https://philipzheng.gitbooks.io/docker_practice/content/_images/cmd_logic.png"><br><br></p>
</li>
<li><p><strong>Docker Renterprise Architecture</strong><br><img src="https://docs.opensvc.com/_images/docker.enterprise.architecture.png"></p>
</li>
</ul>
<h2 id="Docker-철학"><a href="#Docker-철학" class="headerlink" title="Docker 철학"></a>Docker 철학</h2><p><a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="external">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/</a></p>
<blockquote>
<p>Run only one process per container</p>
</blockquote>
<p>위 링크를 보시면 아래 문구의 Docker의 철학이 담겨있습니다. 그 이유는 한개의 이미지에 여러개의 프로세스를 넣으면 확장성과 재사용성이 급격히 저하가 됩니다. 물론 Docker 생태계가 확장하는데도 더 어려워 질것입니다. 이렇듯 그 기술의 철학에 맞게 사용하는것도 매우 중요합니다. 차후 Docker로 이미지를 Build하고 사용하면서 이 부분은 한번 더 집고 넘어가도록 하겠습니다.</p>
<h2 id="왜-Docker-인가"><a href="#왜-Docker-인가" class="headerlink" title="왜 Docker 인가?"></a>왜 Docker 인가?</h2><p>짧지만 핫하디 핫한 Docker(도커)를 살펴보았습니다. DevOps에 무뇌한인 저에게는 개발만이 전부가 아니다 라는 큰 방향을 일깨워주었고, 이렇게 편리한 Tool을 사용하지 않는 것은 죄악이다!! 라는 조금은 단순무식한 결론을 얻었습니다. 실제 프로덕션환경에서 사용경험은 전무하지만 단지 개념만 놓고 보았을때 결론입니다. Docker는 리눅스 컨테이너라는 기존의 <a href="https://ko.wikipedia.org/wiki/%ED%95%98%EC%9D%B4%ED%8D%BC%EB%B0%94%EC%9D%B4%EC%A0%80" target="_blank" rel="external">하이퍼바이저</a>라는 조금은 무거운 과정을 훨씬 가볍게 해주었으며, DevOps의 최전선 기술로 우리의 개발환경을 한층 윤택하게 만들어줄 것이라는 결론과 함께 Docker 살펴보기를 마무리 하겠습니다. 감사합니다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://blog.iolo.kr/510" target="_blank" rel="external">docker getting started: 왕초보를 위한 docker 입문</a><br><a href="http://www.slideshare.net/pyrasis/docker-fordummies-44424016" target="_blank" rel="external">도커 무작정 따라하기</a><br><a href="http://documents.docker.co.kr/" target="_blank" rel="external">Docker 한글 문서 / 영상 모음집</a></p>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://d21ii91i3y6o6h.cloudfront.net/gallery_images/from_proof/1026/large/1396373089/docker.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Docker-란&quot;&gt;&lt;a hre
    
    </summary>
    
      <category term="DevEnv" scheme="https://selo77.github.io/categories/DevEnv/"/>
    
      <category term="Docker" scheme="https://selo77.github.io/categories/DevEnv/Docker/"/>
    
    
      <category term="Docker" scheme="https://selo77.github.io/tags/Docker/"/>
    
      <category term="CD" scheme="https://selo77.github.io/tags/CD/"/>
    
      <category term="DevOps" scheme="https://selo77.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>프로덕션 환경에서 블랭크 페이지를 만난다면?</title>
    <link href="https://selo77.github.io/2016/07/17/How-to-solve-as-meeting-blankpage/"/>
    <id>https://selo77.github.io/2016/07/17/How-to-solve-as-meeting-blankpage/</id>
    <published>2016-07-17T04:40:31.000Z</published>
    <updated>2016-08-03T01:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>현재 저의 역량을 벗어나는 문제를 맞닥뜨렸습니다. 다니고 싶은 회사에 지원을 했고, 파이썬 신의 기를 받아 서류합격을 했습니다. 기쁨도 잠시 인터뷰 진행 전 미션을 받았습니다. 그 중 첫 번째 미션을 정리하면서 최선의 답을 찾아보려합니다.</p>
<h2 id="문제의-이해"><a href="#문제의-이해" class="headerlink" title="문제의 이해"></a>문제의 이해</h2><blockquote>
<p><strong>프로덕션 환경에서 작동하는 WAS(웹 어플리케이션 서버)를 브라우저에서 접속하니 갑자기 블랭크 페이지가 뜹니다.<br>어떤 툴, 서비스 혹은 command를 사용하여 문제를 파악하고 해결할수 있는지 서술해주세요.</strong></p>
</blockquote>
<p>먼저 문제를 자세히 살펴 봅시다. 프로덕션 환경? 블랭크 페이지? 프로덕션 환경이란 실제 현재 서비스 중인 환경이며, 블랭크 페이지란 아래 이미지와 같은 페이지를 의미합니다.<br><img src="https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcRpXOqksDqlSBQaWJb9P0JtwAYskN_zfhxJWFNUX9XxQhewjGRshQ"><br>그렇다면 Blank Page가 뜨는 원인의 파악이 필요할 것이며 다음 단계에서 문제의 원인을 찾아보겠습니다.</p>
<h2 id="문제-원인-파악"><a href="#문제-원인-파악" class="headerlink" title="문제 원인 파악"></a>문제 원인 파악</h2><p>보통 문제에 직면했을때, 크게 두 가지 경우로 나눌 수 있습니다. 문제가 무엇인지 아는 경우와 문제가 무엇인지 모르는 경우입니다. 저는 두번째 경우에 가까웠습니다. 그래서 제가 활동하는 커뮤니티에 도움을 청했고 문제의 접근 방향을 설정 후 진행했습니다.</p>
<p>Blank Page의 원인은 크게 Client상의 문제와 Server상의 문제로 분류할 수 있습니다. 서버 문제의 경우 다양한 원인의 가능성이 있고, 원인을 찾기 위해서 크게 서버 상태확인, 로그 분석, 패킷 분석 등이 필요합니다.</p>
<pre><code>블랭크 페이지 원인 Case 정리
1. Client 문제
  1.1 브라우저
  1.2 악성코드
2. Server 문제
  2.1 WAS 문제
  2.2 네트워크(DNS, 인터넷) 문제
</code></pre><h2 id="문제-해결-단계-설정"><a href="#문제-해결-단계-설정" class="headerlink" title="문제 해결 단계 설정"></a>문제 해결 단계 설정</h2><pre><code>1. Client 문제
  1.1 브라우저 설정확인
  1.2 악성코드 감염 여부 확인
2. Server 문제
  - Server health check
  2.1 WAS 문제
    - WAS Log 분석
    - Packet 분석
  2.2 Network 문제
    - DNS 상태 확인
</code></pre><h2 id="문제-원인-분석"><a href="#문제-원인-분석" class="headerlink" title="문제 원인 분석"></a>문제 원인 분석</h2><h3 id="Client-문제"><a href="#Client-문제" class="headerlink" title="Client 문제"></a>Client 문제</h3><p>  첫번째 가정 Client가 원인인 경우 입니다. 이를 확인 하는 가장 쉬운 방법은 타 장비에서 Domain에 접속해 보는 것입니다. 타 장비에서 정상적 접근이 가능하다면 특정 장비의 문제입니다. 원인은 보통 개인 브라우저의 설정이 잘못되었거나 악성코드에 감염된 경우 입니다. 후자의 경우에는 브라우저 상에서 <a href="https://ko.wikipedia.org/wiki/%EB%8F%84%EB%A9%94%EC%9D%B8_%EB%84%A4%EC%9E%84_%EC%8B%9C%EC%8A%A4%ED%85%9C" target="_blank" rel="external">DNS(Domain Name System)</a>를 임의로 통제하는 경우가 있습니다. 도메인 네임 시스템은 전화번호부 라고 생각하면 쉬운데 악성 바이러스가 전화번호부에 등록된 이름과 번호를 임의로 변경시키게 됩니다. 정리하자면 도메인 이름을 IP 주소로 변환하는 과정에서 정상적인 주소로의 변환이 이루어지지 않습니다. 이와 같은경우는 애드웨어나 백신 프로그램을 통해서 해결할 수 있습니다.</p>
<h3 id="Server-문제"><a href="#Server-문제" class="headerlink" title="Server 문제"></a>Server 문제</h3><p>서버 문제가 원인인 경우 훨씬 복잡합니다. 여기서 부터는 제 지식의 한계와 구체적인 설명을 위하여 스펙을 정의하고 진행하겠습니다.</p>
<ul>
<li>AWS EC2</li>
<li>Linux AMI</li>
<li>WAS - Nginx</li>
<li>로그 분석 환경 - ELKR (ElasticSearch + Logstash + Kibana + Redis)</li>
</ul>
<p>AWS Console에 접속해 Instance의 상태를 확인합니다. Instance의 상태가 정상이라면 Kibana Web에 접속에러 로그를 확인합니다. 블랭크 페이지에서 받았던 Response의  Status Code와 page byte size가 0인 Case를 검색 합니다. (검색 쿼리 예: @fields.status:502 &amp;&amp; @fields.size:537)</p>
<p>케이스를 확인 했으니 Wireshark(패킷 분석툴)를 이용하여 케이스를 테스트 하고 원인을 파악합니다. 이 단계에서 네트워크 통신 과정에서 패킷유실이 있는지도 확인합니다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><h3 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h3><ul>
<li><a href="http://brantiffy.axisj.com/archives/418" target="_blank" rel="external">ELKR (ElasticSearch + Logstash + Kibana + Redis) 를 이용한 로그분석 환경 구축하기</a></li>
<li><a href="http://inverlist.postype.com/post/78617/" target="_blank" rel="external">Wireshark를 통한 패킷 분석</a><h3 id="도움을-주신분들"><a href="#도움을-주신분들" class="headerlink" title="도움을 주신분들"></a>도움을 주신분들</h3></li>
<li>Facebook Group 모여서 각장 코딩하는 모임</li>
<li>스타트업 개발자 모임 인간님</li>
<li>나는 프로그래머다의 Jaeyong_Cho 님</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;현재 저의 역량을 벗어나는 문제를 맞닥뜨렸습니다. 다니고 싶은 회사에 지원을 했고, 파이썬 신의 기를 받아 서류합격을 했습니다. 기쁨도 잠시 인터뷰 진행 전 미션을 받았습니다. 그 중 첫 번째 미션을 정리하면서 최선의 답을 찾아보려합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="DevEnv" scheme="https://selo77.github.io/categories/DevEnv/"/>
    
      <category term="ETC" scheme="https://selo77.github.io/categories/DevEnv/ETC/"/>
    
    
      <category term="ELKR" scheme="https://selo77.github.io/tags/ELKR/"/>
    
      <category term="로그분석" scheme="https://selo77.github.io/tags/%EB%A1%9C%EA%B7%B8%EB%B6%84%EC%84%9D/"/>
    
      <category term="Wireshark" scheme="https://selo77.github.io/tags/Wireshark/"/>
    
      <category term="Packet" scheme="https://selo77.github.io/tags/Packet/"/>
    
  </entry>
  
  <entry>
    <title>AWS Lambda를 활용한 HTTP API 만들기 01</title>
    <link href="https://selo77.github.io/2016/07/13/AWS-LAMBDA01/"/>
    <id>https://selo77.github.io/2016/07/13/AWS-LAMBDA01/</id>
    <published>2016-07-13T12:23:23.000Z</published>
    <updated>2016-07-13T12:30:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR00sVuQRAJAT_CLUVsR6CuwcdYbbPV0FlmT9gRbZdg8cF9tKL0Ng"></p>
<h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR00sVuQRAJAT_CLUVsR6CuwcdYbbPV0FlmT9gRbZdg8cF9tKL0Ng&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Relate
    
    </summary>
    
      <category term="Cloud" scheme="https://selo77.github.io/categories/Cloud/"/>
    
      <category term="AWS" scheme="https://selo77.github.io/categories/Cloud/AWS/"/>
    
    
      <category term="AWS" scheme="https://selo77.github.io/tags/AWS/"/>
    
      <category term="LAMBDA" scheme="https://selo77.github.io/tags/LAMBDA/"/>
    
      <category term="API Gateway" scheme="https://selo77.github.io/tags/API-Gateway/"/>
    
  </entry>
  
  <entry>
    <title>Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 01문제해결과 프로그래밍 대회</title>
    <link href="https://selo77.github.io/2016/07/10/Algorithm-Algorithmic-Problem-Solving-Strategies/"/>
    <id>https://selo77.github.io/2016/07/10/Algorithm-Algorithmic-Problem-Solving-Strategies/</id>
    <published>2016-07-10T05:10:43.000Z</published>
    <updated>2016-07-11T12:59:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론-왜-알고리즘-자료구조를-공부하려-하는가"><a href="#서론-왜-알고리즘-자료구조를-공부하려-하는가" class="headerlink" title="서론 - 왜 알고리즘, 자료구조를 공부하려 하는가?"></a>서론 - 왜 알고리즘, 자료구조를 공부하려 하는가?</h2><p>프로그래밍을 시작하고 거짓말 조금 보태서 하루도 빠짐없이 코딩을 해왔습니다. 그 기간이 오래 되지는 않았지만 쉬지 않고 달려온듯 합니다. 모르는 개념들을 이해하기 위해 닥치는대로 공부하고 어떻게든 해결해왔습니다. 그렇게 현재는 Python을 주 언어로 사용하는 Backend 개발자가 되었고, 현재는 주로 API 개발을 하고 있습니다. 하지만 어느 순간 부터 큰 고민이 생겼습니다. 무언가 만들기 급급한 프로그래밍을 하고 있다는 의구심이었습니다. 아래는 제가 첫 포스트에 썼던 글입니다.</p>
<blockquote>
<p>저에게 파이썬은 아름답습니다. 배우기 쉽고, 간결하며 높은 생산성을 갖고 있습니다. 그렇지만 파이썬 언어도 결국은 프로그래머의 하나의 도구에 불과합니다. <strong><em>단순히 프로그래밍을 할 수 있는 것과 좋은 프로그래밍을 하는 것은 하늘과 땅 차이입니다. 결국 프로그래밍의 수준은 언어가 아닌 프로그래머의 역량입니다.</em></strong> 결론적으로 프로그래밍 자체를 아름답게 하기 위해서는 언어에 상관없이 프로그래밍 자체를 공부해야 합니다. 알고리즘, 디자인패턴, 아키텍처, 테스트기법, 동시성, 자료구조 등의 필요한 지식을 유기적으로 이해할 수 있다면 어떤 언어를 사용하더라도 아름다운 프로그래밍을 할 수 있는 개발자가 될 것이라 생각합니다.</p>
</blockquote>
<p>지금까지 저는 단순히 프로그래밍을 하는 프로그래머였던것 같습니다. 단순히 프로그래밍을 하는 것이 나쁘다는 문제가 아니라 위에서 언급했듯 저는 아름다운 코드를 만드는 프로그래머가 되고 싶습니다. 이를 위한 첫 시작으로 알고리즘과 자료구조를 기초부터 다져나가려 합니다.</p>
<p><img src="http://book.algospot.com/static/img/cover1-small.png"></p>
<p><strong>프로그밍 대회에서배우는 알고리즘 문제해결 전략 (구종만 지음)</strong> 책을 선정해  체계적으로 학습할 계획입니다. 1000페이지가 넘는 다소 버거운 분량임에도 불구하고 이 책을 선정한 이유는 단순히 알고리즘 문제를 소개하고 풀이하는데 그치지 않고, 프로그래밍의 본질인 문제해결이라는 추상적인 개념을 단계를 나누어 체계적으로 학습할 수 있도록 구성되어 있기 때문입니다. 그럼 이제 시작해볼까요!! Let’s go!! Get it!!</p>
<p><a href="http://book.naver.com/bookdb/book_detail.nhn?bid=7058764" target="_blank" rel="external">알고리즘 문제해결전략 책소개 및 목차</a></p>
<h2 id="01-문제-해결과-프로그래밍-대회"><a href="#01-문제-해결과-프로그래밍-대회" class="headerlink" title="01 문제 해결과 프로그래밍 대회"></a>01 문제 해결과 프로그래밍 대회</h2><blockquote><p> <strong>프로그래밍은 문제 해결이다</strong><br>프로그램밍을 하기 위해서는 많은 것을 알아야 합니다. 아무 생각 없이 키보드를 두드리는 것처럼 보이는 프로그래머의 머릿속에는 자신이 사용하고 있는 프로그래밍 언어의 특성, 프로그래밍이 동작할 하드웨어와 운영체제에 관한 지식, 사용하고 있는 라이브러리들에 대한 유의 사항들이 회오리치고 있습니다. (중략) 이 와중에 가능한 한 재사용성이 높은 간결한 코드를 작성해야합니다.<br>이렇게 많은 제약조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력은 좋은 프로그래머가 되기 위해 필수적입니다. 이 책에서는 이런 능력을 문제 해결 능력이라고 부릅니다. 프로그래머가 사용하는 언어나 라이브러리, 알고리즘에 대한 지식 들이 퍼즐의 조각이라면 문제 해결 능력은 적재적소에 퍼즐 조각을 배치하고 이들을 연결해서 큰 그림을 만드는 능력이라고 할 수 있습니다.</p>
<footer><strong>5page</strong><cite>알고리즘 문제해결전략</cite></footer></blockquote>
<p><strong>‘01 문제 해결과 프로그래밍 대회’</strong> 장에서는 문제해결이 무엇인지 정의하고 좋은 프로그래밍을 하기 위해 왜 알고리즘이 필요하고 어떻게 공부해야할지 큰 방향을 제시합니다. 다음 2장 <strong>‘문제 해결 개관’</strong> 은 문제 해결 과정을 여러 단계로 나눠 보고 각 단계를 더 잘하기 위한 여러 기술들을 소개합니다. 책을 구입한지 반년만에 첫 발을 내 딛였습니다. 구종만 작가님이 입문자를 위한 커리큘럼을 제시해주셨고, 저는 그걸 따라 공부할 것입니다. 그렇기에 건너뛰는 장이 있을 수 있음을 미리 말씀드립니다. 첫번째시간은 이렇게 가볍게 마무리하고 다음편에 뵙겠습니다. 행복하세요~</p>
<blockquote>
<p>Well begun is half done</p>
</blockquote>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="http://book.naver.com/bookdb/book_detail.nhn?bid=7058764" target="_blank" rel="external">(책) 알고리즘 문제해결전략 - 구종만</a></li>
</ul>
<p><br><br>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3><a href="/2016/07/10/Algorithm-Algorithmic-Problem-Solving-Strategies-02Solving-Problem-Overview/" title="Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 02문제 해결 개관">Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 02문제 해결 개관</a>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;서론-왜-알고리즘-자료구조를-공부하려-하는가&quot;&gt;&lt;a href=&quot;#서론-왜-알고리즘-자료구조를-공부하려-하는가&quot; class=&quot;headerlink&quot; title=&quot;서론 - 왜 알고리즘, 자료구조를 공부하려 하는가?&quot;&gt;&lt;/a&gt;서론 - 왜 알고리
    
    </summary>
    
      <category term="Base" scheme="https://selo77.github.io/categories/Base/"/>
    
      <category term="Algorithm" scheme="https://selo77.github.io/categories/Base/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://selo77.github.io/tags/Algorithm/"/>
    
      <category term="ProblemSolvingStrategies" scheme="https://selo77.github.io/tags/ProblemSolvingStrategies/"/>
    
  </entry>
  
  <entry>
    <title>Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 02문제 해결 개관</title>
    <link href="https://selo77.github.io/2016/07/10/Algorithm-Algorithmic-Problem-Solving-Strategies-02Solving-Problem-Overview/"/>
    <id>https://selo77.github.io/2016/07/10/Algorithm-Algorithmic-Problem-Solving-Strategies-02Solving-Problem-Overview/</id>
    <published>2016-07-10T05:10:43.000Z</published>
    <updated>2016-07-11T12:58:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-1-도입"><a href="#2-1-도입" class="headerlink" title="2.1 도입"></a>2.1 도입</h2><p>이번장은 추상적인 프로그래밍의 과정을 좀더 체계적으로 수련하기 위한 과정을 여러 단계로 나눠 보고 각 단계를 더 잘하기 위한 전반적인 기술들을 소개합니다. 특히 구체적인 체계없이 프로그래밍을 시작하는 저와 같은 프로그래머들에게 깨닮을 줍니다. 첫번째장에서 알고리즘의 필요성과 공부를 위한 마음을 가다듬었다면 이번장에서는 앞으로 배우게될 것들에 대한 프리뷰가 되겠습니다.</p>
<h2 id="2-2-문제-해결-과정"><a href="#2-2-문제-해결-과정" class="headerlink" title="2.2 문제 해결 과정"></a>2.2 문제 해결 과정</h2><p>알고리즘은 무엇인가? 저는 이렇게 답변했습니다. “알고리즘은 어떤 특정문제를 해결하기 위한 과정과 방법의 정의” 무언가를 공부할때 개념에 대한 본인만의 정의를 갖는것은 매우 중요합니다.</p>
<blockquote>
<p>프로그래밍 대회를 위한 여섯 단계 문제 해결 알고리즘</p>
<ol>
<li>문제를 읽고 이해한다.</li>
<li>문제를 익숙한 용어로 재정의한다.</li>
<li>어떻게 해결할지 계획을 세운다.</li>
<li>계획을 검증한다.</li>
<li>프로그램으로 구현한다.</li>
<li>어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.</li>
</ol>
</blockquote>
<ol>
<li><strong>문제를 읽고 이해합니다.</strong></li>
<li><strong>재정의와 추상화.</strong> 문제를 익숙한 용어로 재정의 하며 추상화 과정을 통해 프로그래밍이 나아갈 방향을 결정합니다. 이 부분에서 추상화를 좀 더 구체적으로 정의하자면, 객체지향에서 현실세계의 존재를 클래스화 하는 과정과 비슷하다고 이해 하시면됩니다. 문제를 우리가 이해하기 쉬운 수학이나 전산 개념으로 표현하는 과정이라 생각합니다. 추상화 과정은 좋은 프로그래머가 되기 위한 필수적인 조건이며 이 단계를 넘지 못한다면 좋은 프로그래머가 되지 못할 것이라 생각됩니다.</li>
<li><strong>계획 세우기.</strong> 이 단계는 문제해결의 과장 중요한 과정이며 사용할 알고리즘과 자료구조를 선택합니다.</li>
<li><strong>계획 검증하기.</strong> 제가 주로 간과하는 부분입니다. 이 단계에서는 시간복잡도와 공간복잡도의 문제를 고려합니다.</li>
<li><strong>계획 수행하기.</strong></li>
<li><strong>회고 하기.</strong> 이 단계는 제가 최근 가장 중요하게 여기는 부분입니다. 블로그에 굳이 공부한 내용을 포스팅 하는이유도 다른 사람에게 보여주기 보다는 회고의 과정을 통해 지식의 견고함을 갖추기 위함입니다. 문제 해결에서 효과적 회고 수행은 문제를 풀 때마다 코드와 함께 본인만의 로그를 남기는 것입니다. 물론 문제를 맞추지 못한 경우에도 해당하며 부족한 부분을 감지하고, 다른 사람의 코드를 보면서 새로운 통찰을 얻곤합니다.</li>
</ol>
<blockquote>
<p><strong>잠시만요!!</strong><br><a href="www.codewars.com">코드전쟁</a> - 사이트 이름처럼 쉬운 문제부터 고난이도 문제까지 닥치는대로 풀어 볼 수  있는 기회를 제공하며, 무엇보다 다른 사람의 작성된 답안을 보면서 코드 작성의 수준을 향상시킬 수 있습니다.</p>
</blockquote>
<h2 id="2-3-문제-해결-전략"><a href="#2-3-문제-해결-전략" class="headerlink" title="2.3 문제 해결 전략"></a>2.3 문제 해결 전략</h2><p>프로그래머에게 문제를 이해하는 직관의 수준은 곧 그 프로그래머의 수준이고 생각합니다. 이렇게 중요한 직관은 하루아침에 만들어 질 수 없으며, 체계적인 학습과 경험 없이는 향상시킬수 없다 생각합니다.</p>
<blockquote>
<h3 id="체계적인-접근을-위한-질문들"><a href="#체계적인-접근을-위한-질문들" class="headerlink" title="체계적인 접근을 위한 질문들"></a>체계적인 접근을 위한 질문들</h3><ul>
<li>비슷한 문제를 풀어본 적이 있던가?</li>
<li>단순한 방법에서 시작할 수 있을까?</li>
<li>내가 문제를 푸는 과정을 수식화할 수 있을까?</li>
<li>문제를 단순화할 수 없을까?</li>
<li>그림으로 그려볼 수 있을까?</li>
<li>문제를 분해할 수 있을까?</li>
<li>뒤에서부터 생각해서 문제를 풀 수 있을까?</li>
<li>순서를 강제할 수 있을까?</li>
<li>특정 형태의 답만을 고려할 수 있을까?</li>
</ul>
</blockquote>
<h2 id="중간-정리"><a href="#중간-정리" class="headerlink" title="중간 정리"></a>중간 정리</h2><p>1장과 2장을 통해 문제 해결 능력을 정의 하고 향상시키기 위해 필요한 과정들을 집어보았습니다. 그럼 다음 포스팅에는 낮은 수준?의 알고리즘을 문제를 풀어보면서 위 에서 학습한 과정과 전략들을 적용해 보겠습니다. 문제 ==&gt; <a href="https://algospot.com/judge/problem/read/FESTIVAL#" target="_blank" rel="external">https://algospot.com/judge/problem/read/FESTIVAL#</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://book.naver.com/bookdb/book_detail.nhn?bid=7058764" target="_blank" rel="external">(책) 알고리즘 문제해결전략 - 구종만</a></li>
</ul>
<p><br><br>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2><a href="/2016/07/10/Algorithm-Algorithmic-Problem-Solving-Strategies/" title="Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 01문제해결과 프로그래밍 대회">Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 01문제해결과 프로그래밍 대회</a>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2-1-도입&quot;&gt;&lt;a href=&quot;#2-1-도입&quot; class=&quot;headerlink&quot; title=&quot;2.1 도입&quot;&gt;&lt;/a&gt;2.1 도입&lt;/h2&gt;&lt;p&gt;이번장은 추상적인 프로그래밍의 과정을 좀더 체계적으로 수련하기 위한 과정을 여러 단계로 나눠 보고
    
    </summary>
    
      <category term="Base" scheme="https://selo77.github.io/categories/Base/"/>
    
      <category term="Algorithm" scheme="https://selo77.github.io/categories/Base/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://selo77.github.io/tags/Algorithm/"/>
    
      <category term="ProblemSolvingStrategies" scheme="https://selo77.github.io/tags/ProblemSolvingStrategies/"/>
    
  </entry>
  
  <entry>
    <title>Python- yield, generator, coroutine</title>
    <link href="https://selo77.github.io/2016/07/05/Python-Asyncio/"/>
    <id>https://selo77.github.io/2016/07/05/Python-Asyncio/</id>
    <published>2016-07-05T11:16:31.000Z</published>
    <updated>2016-07-10T04:58:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AsyncIO"><a href="#AsyncIO" class="headerlink" title="AsyncIO ?"></a>AsyncIO ?</h2><p>아래 그림은 Python3.4 부터 적용된 asyncIO 라는 강력한 비동기 모듈의 프로세스를 간략하게 설명한 그림입니다. 보자마자 머리가 지끈 지끈 아파오기 시작하시져?</p>
<p><img src="https://docs.python.org/3/_images/tulip_coro.png"></p>
<p>비동기, 병령처리, 동시성 너무나 자주 듣는 용어들이지만 깔끔하게 머릿속에 정리가 되지않습니다. 매일 같이 아래와 같은 코딩을 비동기 기반 개발을 함에도 불구하고 반에 반 밖에 이해를 못하고 코딩을 하는것 같습니다.ㅠㅠ 그래서 이번 기회에 포스팅을 통해 AsyncIO 비동기 모듈을 완벽 정복해보려 합니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> module <span class="keyword">import</span> module_dao, module_email</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">an_asyn_fnc</span><span class="params">()</span>:</span></span><br><span class="line">  item = <span class="keyword">yield</span> <span class="keyword">from</span> another_asynfnc()</span><br><span class="line">  asyncio.<span class="keyword">async</span>(module_email(item.email))</span><br><span class="line">  <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">another_asynfnc</span><span class="params">()</span>:</span></span><br><span class="line">  query = <span class="string">"""</span><br><span class="line">  SELECT * FROM users WHERE userID = 'SELO'</span><br><span class="line">  """</span></span><br><span class="line">  dt_user = <span class="keyword">yield</span> <span class="keyword">from</span> module_dao(query)</span><br><span class="line">  <span class="keyword">if</span> dt_user.get(<span class="string">'succeed'</span>, <span class="keyword">None</span>):</span><br><span class="line">    <span class="keyword">return</span> dt_user[<span class="string">'item'</span>]</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception</span><br></pre></td></tr></table></figure>
<p>(위 코딩은 너무 깊게 생각할 가치가 없습니다……. 하지만 한번 눈으로 보시면 아래 개념들을 이해하는데 조금은 도움이 될듯합니다.)</p>
<h2 id="yield-generator-coroutine"><a href="#yield-generator-coroutine" class="headerlink" title="yield, generator, coroutine"></a>yield, generator, coroutine</h2><p>AsyncIO 를 이해하기 위해서 사전에 알고가야 할 개념들이 존재합니다. 바로 오늘 같이 공부해볼 yield 키워드, generator 객체, coroutine 개념입니다. 먼저 yield 키워드와 generator 부터 살펴보겠습니다.</p>
<p><strong>return 처럼 yield는 값을 반환한다. 하지만 yield는 리턴 값을 비롯한 Context(환경) 포함한 제너레이터라는 객체를 반환하는데 이 제네레이터 객체는 iterable(순환가능) 합니다.</strong> 말이 상당히 야리꾸리 합니다. 처음에는 이해가 안되는게 당연합니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">  print(i, end= <span class="string">","</span>) <span class="comment"># 0,1,2,3,4,</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_range</span><span class="params">(end)</span>:</span></span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; end:</span><br><span class="line">    <span class="keyword">yield</span> i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">result = custom_range(<span class="number">5</span>)</span><br><span class="line">print(result) <span class="comment"># &lt;generator object custom_range at 0x1017c5a98&gt;</span></span><br></pre></td></tr></table></figure>
<p>위 custom_range() 함수는 내장함수인 range() 함수를 제너레이터를 이용해 구현한 예입니다.<br>위와 같이 구현된 함수를 코루틴 함수라 합니다. 코루틴? 제너레이터? 여기서는 하나만 기억하고 넘어갑시다. yield가 선언된 함수는 yield를 만나는 순간 제너레이터라는 객체를 반환한다!! 그러면 왜 제너레이터는 순환가능한 것인가? 왜 순환 가능하여야만 하는가? 아래 코드를 보면서 궁금증을 풀어봅시다.</p>
<h3 id="generator는-순환-가능-왜"><a href="#generator는-순환-가능-왜" class="headerlink" title="generator는 순환 가능!! 왜?"></a>generator는 순환 가능!! 왜?</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">  print(i, end=<span class="string">','</span>) <span class="comment"># 0,1,2,3,4,</span></span><br><span class="line">print()</span><br><span class="line">print(list(custom_range(<span class="number">5</span>))) <span class="comment"># [0, 1, 2, 3, 4]</span></span><br><span class="line">print([i <span class="keyword">for</span> i <span class="keyword">in</span> custom_range(<span class="number">5</span>)]) <span class="comment"># [0, 1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">generator = custom_range(<span class="number">2</span>)</span><br><span class="line">print(next(generator)) <span class="comment"># 0</span></span><br><span class="line">print(next(generator)) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 아래코드는 리스트의 아웃오브인덱스 예외와 유사하다. 더이상 진입점이 없으므로 예외를 발생시킨다.</span></span><br><span class="line"><span class="comment"># print(next(generator)) # raise Exception StopIteration</span></span><br></pre></td></tr></table></figure>
<p>위 generator 변수에 대입된 custom_range(2) 함수는 yield 키워드에서 값을 반환하고, 다음 next()에 의해 호출될 때까지 해당 라인을 진입점으로 기억해둡니다. 이러한 진입점이 여러 개 인 함수를 코루틴(coroutine) 이라하며, 기존에 우리가 주로 사용하는 코드를 순서대로 실행하다가 return 코드를 만나고 최종 값을 리턴하면서 context를 잃는 방식을 서브루틴(subroutine)이라고 합니다. 결론은 이미 첫째줄에 말씀드렸는데요. <strong><em>“yield를 만나는 순간 Context(환경)를 포함한 제너레이터라는 객체를 반환.” 결국 제너레이터라는 객체는 코루틴이라는 함수가 진입점을 여러 곳 갖고 있기때문에 호출되는 순서에 따라 Context(환경)이 달라지게 됩니다. 이로 인하여 iterable(순환가능) 할 수 밖에 없는 숙명을 띠게 됩니다.</em></strong></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://b.ssut.me/58" target="_blank" rel="external">Python 3, asyncio와 놀아보기</a><br>rochan87@gmail.com 필자의 머릿속.</p>
<p><strong>잘못된 정보에 대한 지적은 언제든지 감사히 받겠습니다.</strong></p>
<!-- ### Related Posts -->
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AsyncIO&quot;&gt;&lt;a href=&quot;#AsyncIO&quot; class=&quot;headerlink&quot; title=&quot;AsyncIO ?&quot;&gt;&lt;/a&gt;AsyncIO ?&lt;/h2&gt;&lt;p&gt;아래 그림은 Python3.4 부터 적용된 asyncIO 라는 강력한 비동기 모듈의
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Language" scheme="https://selo77.github.io/categories/Python/Language/"/>
    
    
      <category term="python" scheme="https://selo77.github.io/tags/python/"/>
    
      <category term="yield" scheme="https://selo77.github.io/tags/yield/"/>
    
      <category term="generator" scheme="https://selo77.github.io/tags/generator/"/>
    
      <category term="coroutine" scheme="https://selo77.github.io/tags/coroutine/"/>
    
      <category term="asyncio" scheme="https://selo77.github.io/tags/asyncio/"/>
    
  </entry>
  
  <entry>
    <title>나는프로그래머다 - 나프다컨 복기</title>
    <link href="https://selo77.github.io/2016/06/25/iamprogrammer-conference-review/"/>
    <id>https://selo77.github.io/2016/06/25/iamprogrammer-conference-review/</id>
    <published>2016-06-25T08:26:51.000Z</published>
    <updated>2016-06-25T10:59:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://iamprogrammersite.files.wordpress.com/2016/06/2016meetup.png?w=840"></p>
<h1 id="나는프로그래머다-참여-후기-1부"><a href="#나는프로그래머다-참여-후기-1부" class="headerlink" title="나는프로그래머다 참여 후기 1부"></a>나는프로그래머다 참여 후기 1부</h1><p>제목은 참여 후기지만 실상은 두서없는 주저리가 될 것이다.</p>
<h2 id="복기"><a href="#복기" class="headerlink" title="복기"></a>복기</h2><p>나는 프로그래머다 일명 나프다 개발자 컨퍼런스에 참여했다. 컨퍼런스에서 느낀점을 두서 없이 복기 해볼까한다. 자꾸 복기라는 단어를 선택해서 사용하는 것을 이 글을 읽는 분이라면 느꼈을 것이다. 그 이유는 컨퍼런스에서 데니스님이 언급하신 내용 때문이다. 복기란 바둑에서 주로 쓰이는 단어로서 대국이 끝난 후 상대방과 두었던 수에 대해 복습을 의미한다. 나는 학습하는 과정에서 복기를 중요시 여기지 않으며 살아왔다. 내 자신에 대한 자만인지 뭔지는 모르겠지만 한마디로 허접하게 살아왔다.</p>
<p>바둑을 잘 모르는 나를 포함한 많은 사람도 이세돌의 이름 한번쯤은 들어 봤을 것이다. 이세돌은 어떻게 세계최고의 바둑기사가 되었을까? 타고난 천재적 재능? 금수저? 좋은환경? 물론 위에 이유들도 무시할 수는 없을 것이다. 하지만 그는 대국 후 철저한 복기를 하기로 유명하다. 알파고와 대국이 끝난 뒤에도 동료 기사들과 밤새 복기를 했다고 한다. 결론 적으로 알파고가 이겼지만 3연패 뒤 이세돌은 3연승 보다 값진 1승을 이루어 내었다. 그의 1승은 결코 우연이 아닐 것이다. 나는 그의 1승의 가장 큰 이유는 연속된 패배에도 멈추지 않았던 복기를 뽑고 싶다. 복기를 통해 알파고의 약점을 집요하게 파악했고, 자신의 부족함을 보강해 나갔을 것이다.</p>
<p>뛰어난 사람은 생각보다 많다. 특히 나프다 컨퍼런스와 같음 모임에 참여하면 한없이 부족함을 깨닫게 된다. 사실 나같은 경우는 자만할 실력도 없긴하다. 현재는 그렇다. 말하고 싶은 요점은 하나다. <strong><em>뛰어난 사람은 많지만 인정받는 사람은 많지 않다는 점이다. 인정받는 사람 사람이 되기 위해서는 자기 세상에 빠져서는 안된다. 주변을 볼줄 알아야 하고 그렇기 위해서는 항상 깨어있어야한다. 이런 점에 복기는 최고의 방법이 될 수 있다.</em></strong></p>
<p>나는 뛰어난 사람이 되고 싶다. 하지만 인정받지 못하면서 뛰어난 사람이 되고 싶지는 않다. 내가 삶을 살아가는 이유는 내가 사랑하는 사람들에게 인정받고, 내 자신 스스로에게도 인정받고 싶기때문이다.</p>
<p>임백준 작가님께서 라이브 코딩을 선사한 대마고학생들의 뛰어난 재능에도 불구하고 걱정을 표현했던 부분이 이와 같은 맥락이 아닐까 생각한다.</p>
<h2 id="자유와-행복"><a href="#자유와-행복" class="headerlink" title="자유와 행복"></a>자유와 행복</h2><p>이번 주저리는 3번째 세션을 중심으로 이야기를 진행해보겠다. 3번째 세션의 트랙1은 염산악님과 정개발님의 ‘코딩인터뷰 준비 티끌 가이드’였고, 트랙2는 박현천님의 ‘자유와 일을 사랑하는 개발자, 디지털 노마드를 말하다.’ 였다. 나는 트랙2의 박현천님의 트랙을 들었다. 그 이유는 단순하다. 자유라는 주제를 다루고 있었기 때문이다. 왜 개발자로서 삶을 선택했가? 먹고 살기 위해서? 개발이 좋아서? 그냥? 여기에 정답은 없지만 모법답안은 개발이 좋아서 일것이다. 개발이 좋아서 라면 왜 개발이 좋은가? 이 부분을 답하는데 고민이 생긴다면 한번쯤 생각해 보자.</p>
<p>내가 개발을 하는 가장 큰 이유는 자유다. 개발자란 직업은 다른 직업에 비해 자유롭다. 물론 이에 대해 반대되는 의견도 많을리라 생각한다. 하지만 개발자란 단어 그대로 의미를 생각해보면 무언가를 개발하는 직업은 다른 직업에 비해 자유도가 매우 중요하다 생각한다. 나의 부족한 식견때문인지 머릿속에서 맴도는 생각이 잘 정리가 되지 않지만ㅠㅠ 개발자에게 자유는 매우 중요하다. 구체적인 설명이 힘듬으로 예를 들어 설명해보겠다. 최고의 회사 구글을 살펴보자. 그들의 회사는 정해진 규율안에 매우 자유롭다. 강아지와 함께 출근을 하거나 필요한 경우에 원격근무를 하고, 자유로운 복장으로 출근한다. 이외에도 수도 없이 많다. 그리고 그들은 지구 최고의 회사다. 지금으로서는 그렇다.</p>
<p>나의 꿈은 적당히 돈 있는 한량이다. 한량 == 백수. 이유는 간단하다 나는 내가 하고싶은 일을 할 수 있는 자유가 있을때 행복하다. 한량은 자유롭다. 이렇게 내가 쓰고 싶은 말을 하고, 생각하고, 하고 싶은일을 하고, 사랑하는 사람과 함께하며, 사람들에게 인사이트를 주고싶다. 죽을때까지 이꿈을 이룰수 있으리라는 보장은 없지만 이런 미래에 대한 목표가 나를 이끄는 원동력이다.</p>
<p>주저리를 정리해보자면 박현천님의 트랙에 생각보다 적은 사람이 와서 아쉬웠다. 코딩인터뷰 물론 개발자에게 매우 중요한 주제다. 구글의 염산악님과 정개발님께서 발표를 해주신다니 나 같아도 자유라는 단어가 포함된 트랙이 아니였다면 그 트랙에 참여했을 것이다. <strong><em>코딩인터뷰를 준비하고 좋은 회사에 들어가기 전에 본인이 왜 개발을 이렇게 열정적으로 하고 있으며, 개발을 할때 진정 행복한지 한번 쯤 고민을 해보는 시간이 필요하다 생각한다. 특히 “나는 왜 개발하는가?” 질문에 답변이 힘들었다면 말이다.</em></strong></p>
<h2 id="데니스"><a href="#데니스" class="headerlink" title="데니스"></a>데니스</h2><p>데니스님은 귀엽다. 진심이다. 참고로 필자는 약혼자가 있다. 오해금물.</p>
<p>나는 데니스 같은 분을 좋아한다. 나는 데니스님을 보면 김구라가 떠오른다. 나는 김구라도 좋아한다. 데니스는 김구라와 비슷하다. 이 문장은 논리적인가? 삼단추론논법인가 대기업 취업준비를 할때 이런 문장이 논리적인지 판단하는 문제를 풀곤했다. 아무튼 데니스를 김구라에 비유하는 이유는 두분다 독설가이다. 본인이 아니다 하는 생각에 대해서는 열정적으로 비판한다. 비판가는 욕먹기 십상이다. 특히 흑백논리가 편협한 대한민국에서는 그렇다. 임작가님과 같이 노련한 비판가들은 은유적으로 비판한다. 야생에서 오래 서식한 데니스님은 야생마다(발음조심) 우선 아니다 싶으면 아니다 말한다. 컨퍼런스 중에서도 이런면이 여김없이 들어났다. 가끔 마이크를 돌진하시더라.. 가끔은 안쓰럽기도 하다. 나프다 방속에서 어떤 이야기를 함에 있어 임작가님과 데니스님의 맥락이 같음에도 불구하고 데니스님만 욕을 먹을때가 있는 것같다.ㅠㅠ 이래서 표현방식이 중요하다는 것인가?! 하지만 야생마에게 이런 것을 요구하는 오른방법이 아니다. 야생마는 야생마이기에 멋이 있는 것이다.</p>
<p><strong><em>내가 생각하는 대한민국에는 더 많은 야생마가 존재해야한다. 더욱 비판하고, 잘못됨을 일깨워 줘야한다. 데니스님이 꼭 오른말은 한다는 것이 아니다. 다양한 생각이 교류 될 수 있는 환경이 만들어져야 한다는 것이다. 그렇기 위해서는 야생마를 길들여 경주마로 만들려고 하기보다는 야생마가 더 뛰어 다닐 수 있는 환경이 만들어 져야하지 않을까 생각해본다.</em></strong></p>
<p><strong><em>결론 데니스 = 야생마(발음조심)</em></strong></p>
<hr>
<p>항상 머릿속에만 있던 생각을 글로 이렇게 표현 하려니 기운이 쏙쏚 빠진다ㅠㅠ 그래서 너무 배가 고프다. 친구가 왔다. 밥먹으러 가야한다. 그러므로 후기 2부는 다음에 작성해야지~~ 읽어 주시는 분이 있을지 모르지만 읽어 주셨다면 감사합니다(꾸벅). 아 그리고 어떤 의견이든 환영합니다.</p>
<p>마지막으로 우리는!!! 프로그래머닷!!!</p>
<p><img src="https://iamprogrammersite.files.wordpress.com/2016/06/e18482e185a1e18491e185b3e18483e185a12e18480e185afe186abe18491e185ade1848ce185b5.jpeg?w=840"></p>
<p>아참 한빛소프트 부스에서 나프다 2권도 구입!!!<br>사실 대살개문이 더 끌렸지만 좋은 방송을 듣게 해주는 고마움의 표현. 나프다 구입 결정!!!</p>
<h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://iamprogrammersite.files.wordpress.com/2016/06/2016meetup.png?w=840&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;나는프로그래머다-참여-후기-1부&quot;&gt;&lt;a href=&quot;#나는프로그래머다-
    
    </summary>
    
      <category term="Memorandum" scheme="https://selo77.github.io/categories/Memorandum/"/>
    
    
      <category term="나는프로그래머다" scheme="https://selo77.github.io/tags/%EB%82%98%EB%8A%94%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EB%8B%A4/"/>
    
      <category term="나프다" scheme="https://selo77.github.io/tags/%EB%82%98%ED%94%84%EB%8B%A4/"/>
    
      <category term="개발자모임" scheme="https://selo77.github.io/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%AA%A8%EC%9E%84/"/>
    
      <category term="iamprogrammer" scheme="https://selo77.github.io/tags/iamprogrammer/"/>
    
  </entry>
  
  <entry>
    <title>Git 개념 및 유용한 사이트</title>
    <link href="https://selo77.github.io/2016/06/24/git-definition-usefulsite/"/>
    <id>https://selo77.github.io/2016/06/24/git-definition-usefulsite/</id>
    <published>2016-06-24T12:10:09.000Z</published>
    <updated>2016-06-25T10:51:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>안녕하세요. 새로입니다. 오늘은 오픈소스 저장소로 유명한 Git에 대해서 알아보는 시간이 되겠습니다. 이번 토픽을 Git으로 선정하게 된 이유는, 몇일전 회사에서 신규서비스 오픈 중 개고생을 했기때문인데요. 머지와 리베이스 그 지옥에서 벗어나기 위해 발버둥 첬던 밤샘작업. 그 뼈아픈 경험때문에 이번 기회에 git의 필요한 부분을 정리하기로 마음먹었습니다. 포스팅 주제와 관련된 필자의 수준은 다음과 같습니다.(2016-06-06) <br><br><strong>능력 평가는 지극히 주관적임을 먼저 밝힙니다.</strong></p>
<ul>
<li>SVN(형상관리툴) 사용경험 없음.  </li>
<li>참여한 모든 프로젝트에서 Git을 사용했었음 동료에게 피해주지 않을 만큼 정도의 Git사용 실력(가장 중요한 부분!!!)</li>
</ul>
<p>Ps. 누군가 싼 똥은 다른 사람에게 전파된다…..</p>
<h2 id="Git-개념"><a href="#Git-개념" class="headerlink" title="Git 개념"></a>Git 개념</h2><p>먼저 시작하기전에 Git의 기본 개념에 대해 알고 넘어가야겠G요. Git이란 버전관리 시스템으로 쉽게 이해하면 소스코드의 백업공간입니다. 보고서나 어떤 문서를 작성할때 원본파일을 복사하여 복사본을 만들고 수정하셨던 경험이 있을 것입니다. 하지만 파일을 편집할 때 마다 복사본을 만드는 것은 우리모두의 치명적 약점. 언제나 실수 할 수 있다는 점을 생각했을 때 좋지 못한 방법입니다. 그리고 더욱 치명적인 것은 그 작업을 여러명이 진행할 때 실수 확률은 훨씬 더 클것입니다. 언제나 그랬듯이 우리는 우리의 약점을 보완하기 위한 도구를 만들게 됩니다. 그것이 바로 Git과 같은 버전관리 시스템입니다.</p>
<h2 id="Git에-대한-수다"><a href="#Git에-대한-수다" class="headerlink" title="Git에 대한 수다"></a>Git에 대한 수다</h2><p>Git의 사용법은 이 포스팅에서는 따로 하지 않겠습니다. 이유는 체계적으로 정리된 튜토리얼 사이트가 많이 존재하기 때문입니다. 그래서 저는 Git을 사용하면서 느꼈던 점과 중요 포인트를 정리할 예정이며, Git을 공부하실때 제가 언급한 포인트를 생각하면서 공부하시면 좋을것 같습니다.<br>(이번 Git 포스팅은 회사 서비스 오픈과 겹쳐 성의가 많이 떨어짐을 양해 부탁합니다(꾸벅)……….. 우쒸 보기 싫음 보지마 퉤……)</p>
<p>팀원 모두가 잘쓰면 정말 좋은 Git, 아니라면 I’m sure that your team will be in HELL soon. Git을 처음 사용하면 생각보다 복잡한 개념과 사용법에 고전하게 됩니다. 그렇다고 하던 개발을 멈추고, Git을 공부하기란 쉽지않습니다. 결국 개발은 개발대로 진행하고, remote repository에 Push나 Merge를 할때 동료직원중 Git 고수를 소환하여 문제를 해결합니다. 여기까지는 별 문제가 없습니다. 하지만 언제나 함께였던 Git고수 동료가 없을때 문제가 발생합니다.</p>
<p>평소 하던대로 커밋을 하고 풀을 받고, 푸쉬를 하려합니다. 하지만 오랜만에 머지를 해서 그런지 충돌이 난 것같습니다. 충돌때문에 푸쉬가 되지않습니다. 여기서 부터 당황하기 시작합니다. 침착하게 소스코드를 확인합니다. 하지만 방금전까지 멀쩡하던 코드에 뒤죽박죽 빨간줄이 생기고, 에러 천국이 되어버렸습니다. Git을 욕하기 시작합니다. “이 썅개뭐같은것 이딴거 왜쓰는거야?!!”. 욕하는 것도 잠시. 개발한 소스를 갱신하지 않으면 다른 동료 작업에 지장이 있기에 최대한 빨리 푸쉬를 해줘야합니다. 에라 모르겠다. 기존에 백업해둔 로컬 파일을 덮어쓰고 푸쉬합니다. 분명 자기자신만 사용하던 하위 브랜치기에 문제가 없으리라 생각합니다. 참고로 로컬에서는 정상적으로 잘 동작하던 소스였습니다.</p>
<p>다음날 오전…. 해맑게 웃으며 동료들과 스크럼 미팅을 진행합니다. 어제 개발 반영한 것에 대해 다음 작업을 진행할 동료에게 내용을 전달합니다. 5분뒤 누군가의 비명소리가 들려옵니다. “만어ㅣㅁ나어미나엄니ㅏ엄니ㅏ어마ㅣㄴ어ㅣ 내 소스 어디갔어 꺄오꺄오 ㅅㅍㅅㅍ!!!!!” 본능적으로 느낍니다. ‘나구나’ Git을 사용하면서 Overwrite을 하는것은 절대적으로 피해야합니다. <strong><em>충돌은 반드시 소스 내에서 해결하여야 합니다.</em></strong></p>
<h2 id="Git-가지를-치자"><a href="#Git-가지를-치자" class="headerlink" title="Git 가지를 치자!!!"></a>Git 가지를 치자!!!</h2><p>Git을 사용하다보면 어마무지한 뻘짓들을 하게 됩니다. 그러면서 얻은 교훈은 가지를 치자 가지치는데 돈 안들고 가지를 잘 칠 수록 행복해지리라~~!! 제가 사용하는 깃방식을 예를 들면 뿌리 (master)를 토대로 기둥(develop)으로 파생되고, 중심가지(서비스 카테고리. 지금 하는 서비스 같은 경우는 항공, 호텔, 보험 등)들이 자라납니다. 여기까지는 아주 훌륭합니다. 그러나 각 파트에서 개발하는 기능들은 가지를 치지 않는 경우가 발생합니다. 여기서 문제가 발생합니다. 가지를 치지 않은상태에서 진행중인 개발사항을 커밋을 하고 푸쉬를 했다고 칩시다. 그런데 다른 팀원의 기능개발이 끝나 develop 브랜치와 머지를 진행한다 합니다. ‘헐…. 나는 아직 안되는데……. 어쩌지어쩌지 !!! 으악.’ 브랜치만 잘 땃어도ㅠㅠ. 물론 해결방법은 있습니다. 하지만 쓸데없이 추가되는 비용을 발생시킬 필요는 없겠죠~ <strong><em>Git은 가지치기 위해 존재한다. 고로 가지를 치라!!</em></strong></p>
<h2 id="Git-고수가-되고-싶나"><a href="#Git-고수가-되고-싶나" class="headerlink" title="Git 고수가 되고 싶나?"></a>Git 고수가 되고 싶나?</h2><p>아래 reference만 진행하셔도 이미 당신은 깃 고수. 지금 바로시작하세요. 사실 이번 포스팅 Git은 작성하는 동안 흥미가 떨어져서 ㅠㅠ 주저리가 많았네요. 양해부탁드립니다…..(쪼쪼)</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><p><a href="http://learnbranch.urigit.com/" target="_blank" rel="external">Git 브랜치 배우기</a><br>Git으로 협업을 진행할때 가장 중요한 개념인 branch에 대하여 튜토리얼을 통해 학습 할 수 있는 사이트입니다. 제가 PM이라면 신입사원에게 이 사이트의 튜토리얼을 모두 완수하라는 특명을 내리겠습니다!!</p>
</li>
<li><p><a href="https://rogerdudler.github.io/git-guide/index.ko.html" target="_blank" rel="external">git - 간편안내서</a><br>Git의 주요 명령어들이 어떤 상황에서 사용되어야 하는지 쉽게 이해할 수 있는 사이트입니다. 기본적인 git 사용법을 알고 있을때 전체적으로 훓어보기 좋습니다.</p>
</li>
<li><p><a href="http://backlogtool.com/git-guide/kr/" target="_blank" rel="external">누구나 쉽게 이해할 수 있는 Git 입문</a><br>이 사이트의 내용을 모두 이해하셨다면 나는 이미 Git 도사!!! Git의 전반적인 내용을 다루고 있습니다. 버전관리 시스템을 처음 접하시는 분 부터 이미 Git을 사용하시는 분까지 적합한 사이트입니다.</p>
</li>
</ul>
<p>아래 코드는 에러코드입니다. 신경쓰이겠지만 신경쓰지마세요.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Git</span><span class="params">(version_control_system)</span>:</span></span><br><span class="line"></span><br><span class="line">    local = &#123;</span><br><span class="line">        <span class="string">"master"</span> : source</span><br><span class="line">        <span class="string">"develop"</span> : source0</span><br><span class="line">        <span class="string">"feature"</span> : &#123;</span><br><span class="line">            <span class="string">"new_service"</span> : source1_0,</span><br><span class="line">            <span class="string">"new_feature"</span> : source2,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remotes.origin = &#123;</span><br><span class="line">        <span class="string">"master"</span> : source</span><br><span class="line">        <span class="string">"develop"</span> : source0</span><br><span class="line">        <span class="string">"feature"</span> : &#123;</span><br><span class="line">            <span class="string">"new_service"</span> : source1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">commit</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkout</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rebase</span><span class="params">(self)</span>:</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;안녕하세요. 새로입니다. 오늘은 오픈소스 저장소로 유명한 Git에 대해서 알아보는 시간이 되겠습니다. 이번 토픽을 Git으로 
    
    </summary>
    
      <category term="DevEnv" scheme="https://selo77.github.io/categories/DevEnv/"/>
    
      <category term="Git" scheme="https://selo77.github.io/categories/DevEnv/Git/"/>
    
    
      <category term="DevOps" scheme="https://selo77.github.io/tags/DevOps/"/>
    
      <category term="GitHub" scheme="https://selo77.github.io/tags/GitHub/"/>
    
      <category term="Git" scheme="https://selo77.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>NoSQL 개념 및 종류</title>
    <link href="https://selo77.github.io/2016/06/24/nosql-definition-basic/"/>
    <id>https://selo77.github.io/2016/06/24/nosql-definition-basic/</id>
    <published>2016-06-24T03:01:13.000Z</published>
    <updated>2016-06-24T11:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc orderedList:0 -->
<ul>
<li><a href="#nosql-그리고-mongodb-입문">NoSQL 그리고 MongoDB 입문</a></li>
<li><a href="#nosql-개념과-특징">NoSQL 개념과 특징</a></li>
<li><a href="#nosql-탄생배경">NoSQL 탄생배경</a></li>
<li><a href="#nosql-분류">NoSQL 분류</a></li>
<li><a href="#언제-어떤-nosql을-사용해야-하는가">언제 어떤 NoSQL을 사용해야 하는가?</a></li>
<li><a href="#결론">결론</a></li>
<li><a href="#reference">Reference</a><ul>
<li><a href="#related-posts">Related Posts</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2 id="NoSQL-그리고-MongoDB-입문"><a href="#NoSQL-그리고-MongoDB-입문" class="headerlink" title="NoSQL 그리고 MongoDB 입문"></a>NoSQL 그리고 MongoDB 입문</h2><p>이번 Side Project의 기술 스택으로 Meteor를 채택 진행하게되었고, 나는 Data Modeling을 맡았다. 그러나 RDBMS만 사용해본 나에게 모든 것은 새롭게 다가 왔고, Mean Stack이나 Meteor Tutorial 정도만 진행한 미천한 실력으로는 어려움을 느꼈다. 그렇게 프로젝트의 성공을 위해 NoSQL 공부를 시작한다.</p>
<p>이 글의 작정자의 수준은 아래와 같습니다.</p>
<ul>
<li>RDBMS 중급. MySQL, ORACLE 사용 경험</li>
<li>RDBMS data Modeling 초급</li>
<li>Redis 초급</li>
<li>NoSQL 초급</li>
</ul>
<h2 id="NoSQL-개념과-특징"><a href="#NoSQL-개념과-특징" class="headerlink" title="NoSQL 개념과 특징"></a>NoSQL 개념과 특징</h2><p>NoSQL : Non-Relational Operational Database SQL. 또는 Not only SQL<br>마틴 파울러의 [NoSQL: 빅데이터 세상으로 떠나는 간결한 안내서]에서 NoSQL은 아래의 조건을 만족하는 데이터라 정의했다.</p>
<ol>
<li>대용량 웹 서비스를 위하여 만들어진 데이터 저장소</li>
<li>관계형 데이터 모델을 지양하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화된 저장소</li>
<li>스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소</li>
</ol>
<p>NoSQL을 잘못 이해하면 스키마가 없는 DataModel 이라 이해할 수 있는데 그렇지 않다는 점을 집고 넘어가자. NoSQL은 각 시스템 마다 고유한 특징을 가진다. 하지만 일반적인 특징을 정의하고 넘어가자면, <strong><em>읽기 작업보다 쓰기 작업이 더 빠르며, 일반적으로 RDBMS에 비하여 쓰기와 읽기 성능이 월등히 빠르다. 그러나 NoSQL은 제대로 알고 쓰지 못하면 성능 저하를 불러오고, 문제를 발생시킨다.</em></strong></p>
<p>필자가 참여한 프로젝트에서는 검색속도 개선을 위해 Redis를 사용하는데 서버가 죽는 경우 Redis를 갱신시키는데 많은 시간을 소모하여, 복구 작업이 몇배는 더 걸린 경험이 있다.</p>
<h2 id="NoSQL-탄생배경"><a href="#NoSQL-탄생배경" class="headerlink" title="NoSQL 탄생배경"></a>NoSQL 탄생배경</h2><p>NoSQL이 뭐시고 저시고 공부를 하다 문득 한가지 의문이 생겼다. RDBMS라는 확고한 Database 시스템이 존재하는데!!!! 왜???? 기존의 패러다임과는 너무나도 상반된 NoSQL 시스템이 나타난것인가?!!!</p>
<p>빅데이터 세상을 맞이함에 있어 구글과 같은 대규모 서비스 업체들은 관계형 데이터베이스 만으로 트래픽을 감당하기 어려워젔고, 이를 해결 하기 위한 결과로 NoSQL을 탄생시켰다. NoSQL은 분산 환경에서 대용량의 데이터를 빠르게 처리하기 위해서 단점을 가진채 개발되었다.</p>
<h2 id="NoSQL-분류"><a href="#NoSQL-분류" class="headerlink" title="NoSQL 분류"></a>NoSQL 분류</h2><p>NoSQL은 분류 방식에 따라 다르게 나누어진다. 이 글에서는 키에 저장된 값의 데이터 형식에 따라서 분류하겠다. <br></p>
<ul>
<li>키-값 모델 <br><blockquote>
<p>키 값 모델의 가장 큰 특징은 단순한 저장구조를 갖으며, 복잡한 조회 연산을 지원하지 않는다. 저장되는 값을 단지 의미 없는 바이너리 데이터로 처리. 고속 읽기와 쓰기에 최적화된 경우가 많다. <br><br>키-값 모델 NoSQL 예 : Redis, Riak 등 <br><br>키-값 모델의 특징을 고려해 볼때, 단일 연산에 처리할 수 있는 데이터들을 저장하는데 적합하다. 참여한 프로젝트의 경우는 자주검색되는 데이터를 Redis에 set하고, RDBMS 조회전에 Redis를 먼저 바라봄으로서 검색속도를 비약적으로 개선했다. <strong><em>결론, 하나의 서비스 요청에 단일 연산 처리로 대응할수 있는 시스템에 적합하다.</em></strong></p>
</blockquote>
</li>
</ul>
<p><br></p>
<ul>
<li>문서 모델 <br><blockquote>
<p><strong><em>문서모델 NoSQL 은 하나의 키에 구조화된 문서를 저장하고 조회한다.</em></strong>  문서모델에서 의미하는 구조화된 문서란 가장 대표적으로 JSON이 있으며, XML과 같이 구조를 갖는 문서를 말한다. 저장된 문서를 컬렉션으로 관리하고, 저장과 동시에 문서 ID에 대한 인덱스를 생성한다. 문서모델의 키는 문서에 대한 ID로 표현됨. 키-값 및 컬럼 모델에 비하여 많은 종류의 기능을 제공하며, <strong><em>RBMS와 유사한 검색조건을 포함한 쿼리를 처리할 수 있다.</em></strong> 이러한 특징 덕분에 문서모델 NoSQL은 많은 인기를 얻고 있다. 대부분의 문서 모델 NoSQL은 B트리 인덱스를 사용하여 2차 인덱스를 생성한다.  그러나 B트리는 크기가 커질수록 새로운 데이터를 입력하거나 삭제할때 성능이 떨어지게 된다. 이러한 이유로 B트리를 사용하는 문서 모델 NoSQL은 읽기와 쓰기 비율을 7:3 이상으로 유지할때 더 좋은 성능을 보인다. <strong><em>결국 사용하는 문서 모델 NoSQL의 특징을 파악하고 사용하자.</em></strong> <br><br>B트리의 특성 떄문에 한 번 작성되면 자주 변하지 않는 정보를 저장하고 조회하는데 적합하며, 로그저장, 타임라인 저장, 채팅로그 기록이나 조회에 적합하다. <br><br>문서 모델 NoSQL 예: 많은 인기를 얻고 있는 MongoDB <br><br>NoSQL의 개념을 빠르게 잡고 MongoDB를 학습, 프로젝트를 진행할 예정이다. 여러분 함께해요~.</p>
</blockquote>
</li>
</ul>
<p><br></p>
<ul>
<li>그 밖의 모델<blockquote>
<p>위 두가지 모델 이외에도 컬럼 모델 NoSQL, 그래프 모델 NoSQL 등이 있으나 필자의 능력을 벗어남을 판단했다. 다음 가장 중요한 파트라 생각되는 “언제 어떤 NoSQL을 사용해야 하는가?”로 넘어가겠다.</p>
</blockquote>
</li>
</ul>
<h2 id="언제-어떤-NoSQL을-사용해야-하는가"><a href="#언제-어떤-NoSQL을-사용해야-하는가" class="headerlink" title="언제 어떤 NoSQL을 사용해야 하는가?"></a>언제 어떤 NoSQL을 사용해야 하는가?</h2><p>NoSQL은 RDMS를 단순히 대체하기 위해 나온 시스템이아니다. 그렇기에 정확한 기본지식 없이 사용하면 많은 시행착오와 장애를 맞이하게 될 수 있다<br>그렇다면 NoSQL 시스템을 서비스에 적용하기 위해서는 무엇이 필요할지 정리해 볼 것이다.<br>작성자의 수준에 맞춰 이해가 어려운 부분은 제외 하였으니 더 많은 정보를 원한다면 아래 Reference를 참고하기 바란다.</p>
<p>대량의 단순 정보를 빠르게 저장하고 조회할 때, 관계형 데이터베이스가 처리하지 못하는 대량의 데이터를 입력할때 스키마가 고정되지 않은 데이터를 저장하고 조회할 떄 등이 이에 해당된다. 하지만 위와 같은 상황에서 무턱대고 아무 NoSQL을 적용한다면 큰 낭패를 보게 될 것이다. <strong><em>결국 시스템의 상황을 고려하여, 서비스 특징에 맞는 적합한 NoSQL 저장소를 택하여야 한다.</em></strong>  NoSQL의 선택에 있어 고려해야 할 사항으로는 다음과 같다.</p>
<ul>
<li>일관성 모델 : 서비스에서 저장하려는 데이터가 어느 정도의 일관성이 필요한지 확인하여야한다.</li>
<li>데이터 모델 : 저장하려는 데이터가 키-값 모델과 같은 간단한 데이터 모델로 처리가 가능한지 또는 문서 모델과 같이 중첩된 구조를 지원해야 하는지 판단해야 한다.</li>
<li>읽기 쓰기 성능 : 앞에서 말했듯이 읽기와 쓰기 비율에 따라서 적합한 NoSQL이 다르다. 빠른 응답시간이 필요하다면 인메모리 NoSQL이 적합하며, 상대적으로 읽기 비율이 높다면 문서-모델 NoSQL이 후보가 될 수 있다. (듣던 중 반가운 소리!! 필자가 개발하는 서비스의 특성상 읽기의 비율이 높다.)</li>
<li>원자성 지원 : 선택한 NoSQL의 트랜잭션 지원 여부, 단일 연산에 대한 연자성 지원 여부 등도 학인해야 한다. (이 부분은 확인 필요)</li>
</ul>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p><strong><em>장점만 갖는 시스템은 존재하지 않는다. NoSQL의 환상에 빠지지 말고, 서비스가 NoSQL 적용이 적합한지, 적합하다면 어떤 NoSQL 이 알맞는지 판단하여야 할 것이다.</em></strong></p>
<p>위 내용은 아래 Reference의 내용을 토대로 작성되었습니다. 특히, 이번 포스팅은 제가 즐겨 듣는 팟케스트 꿈과 희망의 나는프로그래머다 공식 후훤사 한빛미디어의 책 “정경석 - 이것이 Redis다” 를 주로 참고하였습니다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://bcho.tistory.com/666" target="_blank" rel="external">http://bcho.tistory.com/666</a><br><a href="http://bcho.tistory.com/665" target="_blank" rel="external">http://bcho.tistory.com/665</a><br><a href="https://velopert.com/436" target="_blank" rel="external">https://velopert.com/436</a><br>책 : 정경석 - 이것이 Redis 다</p>
<h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc orderedList:0 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#nosql-그리고-mongodb-입문&quot;&gt;NoSQL 그리고 MongoDB 입문&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#nosql-개념과-특징&quot;&gt;NoSQL 개념과 특징&lt;/
    
    </summary>
    
      <category term="NoSQL" scheme="https://selo77.github.io/categories/NoSQL/"/>
    
      <category term="Basic" scheme="https://selo77.github.io/categories/NoSQL/Basic/"/>
    
    
      <category term="NoSQL" scheme="https://selo77.github.io/tags/NoSQL/"/>
    
      <category term="MongoDB" scheme="https://selo77.github.io/tags/MongoDB/"/>
    
      <category term="Redis" scheme="https://selo77.github.io/tags/Redis/"/>
    
      <category term="Database" scheme="https://selo77.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Python - Python?</title>
    <link href="https://selo77.github.io/2016/06/23/Python-definition/"/>
    <id>https://selo77.github.io/2016/06/23/Python-definition/</id>
    <published>2016-06-23T11:17:28.000Z</published>
    <updated>2016-07-10T06:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc orderedList:0 -->
<ul>
<li><a href="#python-이란-사랑입니다"><strong>Python 이란? 사랑입니다.</strong></a><ul>
<li><a href="#개요">개요</a></li>
<li><a href="#특징">특징</a><ul>
<li><a href="#높은-생산성">높은 생산성</a></li>
<li><a href="#간결-그리고-아름다움">간결 그리고 아름다움</a></li>
<li><a href="#반복-가능한-객체">반복 가능한 객체</a></li>
<li><a href="#만능-언어">만능 언어</a></li>
</ul>
</li>
<li><a href="#결론">결론</a></li>
<li><a href="#reference">Reference</a><ul>
<li><a href="#related-posts">Related Posts</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1 id="Python-이란-사랑입니다"><a href="#Python-이란-사랑입니다" class="headerlink" title="Python 이란? 사랑입니다."></a><strong>Python 이란? 사랑입니다.</strong></h1><p>이 포스팅은 가로 1400px 이상의 화면에 최적화 되있습니다.</p>
<p>저는 Python 개발자입니다. 매일 같이 Python을 사용하여 로직을 구현하고, 프로그램을 작성합니다. Python은 정말 재밌습니다. 간결한 문법, 상상을 뛰어넘는 가독성!! 무엇보다 생산성에서는 제가 접한 몇개 안되는 언어들 중 최고에 속합니다. 또한 풍부한 모듈과 내장함수들은 Python과 사랑에 빠지게 만듭니다.</p>
<p>그러나 Python에 대한 열정만큼 Python을 특징을 잘 파악하지 못하고, 단순히 내장함수나 모듈을 쓰는 단계에서 그치는 것이 아닌가 라는 걱정을 하게되었고, 파이썬의 특징을 집고 넘어가자는 취지로 포스팅하게 되었습니다.</p>
<p>포스팅 주제와 관련된 필자의 수준은 다음과 같습니다. (능력 평가는 지극히 주관적임을 밝힙니다.)</p>
<pre><code>사용가능 언어
- Java7 중급
- Python3 중급
- ECMA6 중급
</code></pre><p>(하나 라도 제대로 해야할텐데 ㅠㅠ 그래서 요즘은 파이썬에 집중하려 합니다. 하지만 이놈의 호기심 때문에 함수형 언어에 기웃기웃하고 있네요.)</p>
<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>파이썬은 1989년 귀도 반 로썸의 재미로 만들어젔습니다. 리눅스 토발즈의 리눅스도 그렇고 천재들은 심심할때 대작을 만드는 듯합니다.</p>
<p><em>파이썬은 문법이 매우 쉬워서 초보자들이 처음 프로그래밍을 배울때 추천되는 언어이며, 동시에 실사용률과 생산성도 높은 강력한 언어입니다.</em></p>
<p><a href="http://www.tiobe.com/tiobe_index" target="_blank" rel="external">2016년 5월 기준 토비 프로그래밍 언어 월간 점유율</a> 을 확인해보시면 현재 5위에 랭크되있습니다.</p>
<p>범용 프로그래밍언어로서 초보자부터 전문가까지 넓은 사용자층을 보유하고 있습니다. 변수의 자료형을 선언하지 않는 <strong>동적 타이핑 언어</strong> 이며(Runtime에 자료형을 검사), <strong>인터프리터</strong> 에 의해 해석과 동시에 프로그램이 실행되는 스크립트 언어입니다.</p>
<p>파이썬은 현재 지속적인 발전과 더 많은 사용자층을 확보해가고 있습니다. 구글에서는 C++, JAVA와 함께 3대 개발 언어 중 하나로 알려져 있습니다. 최근 파이썬은 deep learning, data science 등 트렌디한 분야에서 특히 많이 사용되고있습니다. machine learning에 관심 있는 분이라면 Google이 개발한 deep learning 라이브러리인 TensorFlow를 권해드립니다. 역시 구글신!!</p>
<h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><p>파이썬은 정말 다양한 분야에서 쓰이고있습니다. 그 이유는 파이썬의 다양한 특징때문일 것입니다. 그럼 같이 파이썬에 특징에 대해 알아볼까요. Here we go~!!</p>
<ul>
<li><h3 id="높은-생산성"><a href="#높은-생산성" class="headerlink" title="높은 생산성"></a>높은 생산성</h3><p><strong>Life is short, you need python (인생은 너무 짧으니 파이썬이 필요해)</strong><br>인터프린트 언어이면서 우수한 자료형과 내부 모듈 등을 제공해 개발기간을 단축시킬 수 있습니다. 또한 수많은 오픈 서드파트 라이브러리를 사용하시면 그 속도를 배가 시킬수있습니다.<br><br>빠른 아이디어 구현이 중요한 연구소에서 각광 받고 있으며, 우리나라에서는 정부의 자바라는 큰 장벽이 존재함에도 불구하고, 스타트업에서 가장 많이 사용하는 언어 중 하나입니다. 기술트렌드에 민감한 스타트업 기업들을 위한 전문 채용 사이트 살펴본다면, Python의 인기를 실감할 수 있습니다.<br><a href="https://www.rocketpunch.com/" target="_blank" rel="external">로켓펀치 - 스타트업 백과사전</a><br><br>PS. 사실 파이썬은 우리나라를 제외한 다른 나라에서는 이미 오래전부터 주류 언어로 사용되고 있었습니다.</p>
</li>
</ul>
<ul>
<li><h3 id="간결-그리고-아름다움"><a href="#간결-그리고-아름다움" class="headerlink" title="간결 그리고 아름다움"></a>간결 그리고 아름다움</h3><p>아름다움의 정의는 개개인마다 다를 수 있습니다. 하지만 다수가 인정하는 미의 기준은 한 곳에 수렴하기 마련입니다. 파이썬의 디자인 철학은 아름다움의 수렴이라는 포커스에 맞춰져있습니다.<br><br>가장 아름다운 하나의 답이 존재한다. 앞의 명제는 파이썬의 모토이며 이와 같은 대 명제를 토대로 다음과 같은 철학을 지니게 되었습니다.<br></p>
<ul>
<li>아름다운 것이 추한 것보다 낫다.</li>
<li>명시적인 것이 암시적인 것보다 낫다.</li>
<li>간결한 것이 복잡한 것보다 낫다.</li>
<li>정교한 것이 난잡한 것보다 낫다.</li>
</ul>
<p>저는 이와 같은 디자인 철학에 백퍼센트 동의하진 않지만, 복잡하지 않으면서 명확하고, 심플한 파이썬스러움은 파이썬을 사용하기에 충분히 매력적으로 다가 왔습니다. 파이썬스러움(pythonic)한 코드를 짜기 위한 몇가지 규칙이 정의 되어있는데 PEP8 이라는 코드 스타일 규정이 존재합니다. <br><br><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="external">PEP 8 – Style Guide for Python Code</a><br><a href="https://spoqa.github.io/2012/08/03/about-python-coding-convention.html" target="_blank" rel="external">파이썬 코딩 컨벤션</a><br><br>이러한 아름다움과 간결한 문법 덕분에 파이썬은 배우기 쉬우며, 높은 가독성을 제공합니다. 덕분에 C, C++, JAVA 같은 언어로 개설 되던 대학 수업들이 Python으로 옮겨 가는 추세입니다. 우리나라 대학 중에는 연세대, 카이스트, 부산대, 국민대, 인천대에서 이미 프로그래밍 개론 수업을 Python으로 진행하고 있습니다.</p>
</li>
<li><h3 id="반복-가능한-객체"><a href="#반복-가능한-객체" class="headerlink" title="반복 가능한 객체"></a>반복 가능한 객체</h3><p>프로그래머에게 조건문과 반복문은 컴퓨터와 소통하는 가장 중요한 도구 중 하나에 속합니다. 파이썬에는 반복 가능한 객체(iterable)가 존재하는데, 기존의 반복문이 청동무기 였다면 철무기쯤으로 업그레이드 시켜줍니다. <br><br>이 객체는 집합, 문자열, 튜플, 딕셔너리, 그리고 함수 등 iterable한 모든 객체를 의미합니다. 이뿐만 아니라 반복 가능한 객체에는 헬퍼 메소드가 존재하여 생산성 또한 증가시킵니다. 특히 함수의 반복은 큰 장점이 됩니다. 아래 작성한 코드를 보시고 어느 로직에 응용할 수 있을지 생각해보세요~.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiple</span><span class="params">(n)</span>:</span></span><br><span class="line">  x = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">yield</span> n*x</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">f = factorial(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># print(f.__next__()) # 10</span></span><br><span class="line"><span class="comment"># print(f.__next__()) # 20</span></span><br><span class="line"><span class="comment"># print(f.__next__()) # 30</span></span><br><span class="line"></span><br><span class="line">print(next(f)) <span class="comment"># 10</span></span><br><span class="line">print(next(f)) <span class="comment"># 20</span></span><br><span class="line">print(next(f)) <span class="comment"># 30</span></span><br></pre></td></tr></table></figure>
<p>위 코드의 프린트 값을 보면 함수가 값을 리턴했음에도 함수 내부 환경이 유지 됩니다. 자바스크립트를 공부하신 분이라면 클로져가 떠오를 수도 있겠지요. <br><br>Anyway 위 함수가 종료되기 전까지 지역변수를 유지합니다. 결국 위의 함수의 계속 호출한다면 값은 지속적으로 증가하겠지요?</p>
</li>
<li><h3 id="만능-언어"><a href="#만능-언어" class="headerlink" title="만능 언어"></a>만능 언어</h3><p>최근의 언어트렌드는 높은 생산성과 만능언어가 아닐까 생각합니다. 물론 분야마다 차이는 존재하지만 명백한 사실입니다. 인기도를 측정해볼 수 있는 척도중 하나인 Stack Over Flow의 언어 카테고리당 질문율을 살펴보면 정확한 수치도 확인할 수 있습니다.<br><a href="http://stackoverflow.com/research/developer-survey-2016" target="_blank" rel="external">2016 Stack overflow - Developer Survey Results</a><br><br>그렇다면 파이썬은 어떤면 때문에 만능언어일까요? <br><br>첫번째, 이유는 Python으로 공급되는 다양한 분야의 방대한 패키지입니다.<br>궁금하신분은 아래 사이트를 참고하세요.<br><a href="http://pypi-ranking.info/alltime" target="_blank" rel="external">PyPL Ranking</a> <br><br>두번째, 다양한 자료구조와 글루언어(다른언어와 접착성)로서의 역할 입니다.<br>이 부분을 언급하기전에 파이썬의 단점 하나를 집고 넘어가자면 속도입니다. 실행환경에서 타입을 설정하는 언어의 특성상 느릴수 밖에 없지만, 다른 동적 언어들(JavaScript, LISP …)과 비교해봐도 속도가 빠른편은 아닙니다. 하지만 다른언어들(C, JAVA 등 메인언어)과의 높은 결합성 덕분에 속도적인 이슈가 있는 부분은 C로 작성하고, 생산성이 중요한 부분은 Python으로 작성한다면 속도 이슈를 해결할 수 있습니다. 특히, Python 자체가 C로 구현되었기 때문에 C와 궁합이 잘 맞는다고 합니다.</p>
</li>
</ul>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>저에게 파이썬은 아름답습니다. 배우기 쉽고, 간결하며 높은 생산성을 갖고 있습니다. 그렇지만 파이썬 언어도 결국은 프로그래머의 하나의 도구에 불과합니다. <strong><em>단순히 프로그래밍을 할 수 있는 것과 좋은 프로그래밍을 하는 것은 하늘과 땅 차이입니다. 결국 프로그래밍의 수준은 언어가 아닌 프로그래머의 역량입니다.</em></strong> 결론적으로 프로그래밍 자체를 아름답게 하기 위해서는 언어에 상관없이 프로그래밍 자체를 공부해야 합니다. 알고리즘, 디자인패턴, 아키텍처, 테스트기법, 동시성, 자료구조 등의 필요한 지식을 유기적으로 이해할 수 있다면 어떤 언어를 사용하더라도 아름다운 프로그래밍을 할 수 있는 개발자가 될 것이라 생각합니다. <br><br>PS. 부족한 하거나 잘 못된 부분에 대한 지적은 감사히 받겠습니다. 부족한 글 끝까지 읽어주셔서 감사합니다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://wikidocs.net/book/1" target="_blank" rel="external">점프 투 파이썬 : Python의 기본을 쉽게 익히기에 좋은 사이트</a><br><a href="https://ko.wikipedia.org/wiki/파이썬" target="_blank" rel="external">파이썬 - 위키백과</a><br><a href="https://namu.wiki/w/Python" target="_blank" rel="external">파이썬 - 나무위키</a><br>rochan87@gmail.com 필자의 머릿속.</p>
<hr>
<h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc orderedList:0 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#python-이란-사랑입니다&quot;&gt;&lt;strong&gt;Python 이란? 사랑입니다.&lt;/strong&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#개요&quot;&gt;개요&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Language" scheme="https://selo77.github.io/categories/Python/Language/"/>
    
    
      <category term="python" scheme="https://selo77.github.io/tags/python/"/>
    
  </entry>
  
</feed>
